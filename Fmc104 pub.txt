' This is an OCR of a scan of a printout. Later versions exist, but source is lost
' GFA BASIC, Amiga
' -----------------------------------------------------------------------------
' FMC
' Version 1.04
' (c) John Valentine 1990/1993
' Revision #020 (change after modification)          Revision Date: 19/03/93
' -----------------------------------------------------------------------------
' Todos:
' - Sample rate independence
' - Consolidate Operator type data
' - Log scale option on envelopes. Or capacitor-like
' - Curve interpolate operator sources
' - Better oscillator resolution
' - Oversample and write at 1/2 (?) generated rate? For FM, ... (slower!)
' - Better power spectrum. FFT?
' - Parameter modulation, like envelopes (performance emulation)
' - Sequencer?
' ...
RESERVE 50000
' --- COMPILER OPTIONS ---------------
$m50000
$S>
$E$
' --- PROGRAM ------------------------
ON ERROR GOSUB trapper
~SetTaskPri(FindTask(0),0)
setup
main
tidyupfmc
END
' -----------------------------------------------------------------------------
' --- OPENING & CLOSING -------------------------------------------------------
PROCEDURE setup                     !! SCREEN, IDCMP, ARRAYS, Globals
  dcmd$=_dosCmd$                ! Test command line
  IF LEFT$(dcmd$,4)="NTSC"      ! NTSC option - opens screen to 400 lines
    dcmd$=MID$(dcmd$,6)         !    hardly implemented in rest of program!
    scnht%=400
  ELSE
    scnht%=512
  ENDIF
  tbargap%=11
  IF dcmd$=""                   ! Helpfile directory
    dcmd$="dh0:sound/"
  ENDIF
  help$="FMC"
  SETWPEN 0,0                    ! Open Screen, window, set palette
  OPENS 1,0,0,640,scnht%,2,32772
  TITLES #1,"FMC105� Sample-Generating Algorithm Synthesizer � John Valentine 1990/93"
  OPENW #1,0,0,640,scnht%,&H8,&HD00
  palette(&HAAA,&H0,&HFFF,&HDD0)
  win%=WINDOW(1)                 ! Window structure -> win%
  ~ActivateWindow(win%)
  softfont                       ! Set FMC/11 font
  path$="RAM:Voice"
  tpath$="RAM:Voice1.FMC"
  no|=24        ! Max. number of operators
  ee|=1
  bw&=36        ! Box dimensions
  bh&=29
  DIM f(no|),od(15),ep(no|,16),et(no|,16),oep(no|),oet(no|),v(no|),ec|(no|),d%(no|,15)
  DIM opx|(20),opz|(20),opm$(20),opn$(20),tab(4,640),rd(7),ox&(no|),oy&(no|),s$(48),sl%(48),fln%(48)
  DIM m68%(16)
  od(0)=1                       ! default performance data
  od(1)=0
  od(2)=1000
  masttun=0
  mtun=1
  RESTORE vcdat                 ! Default Operator Data
  FOR n|=1 TO no|               ! - really needs default data for each type
    resetop(n|,TRUE)            ! - of operator, and a routine to reset an
  NEXT n|                       ! - operator, eg. ResetOpData(OpNum|,Type|)
  FOR n|=1 TO no|
    envdatareset(n|)
  NEXT n|
  RESTORE opt
  FOR n|=1 TO 10                ! Screen co-ords operators
    READ opx|(n|),opz|(n|),opm$(n|)
    opz|(n|)=ADD(opz|(n|),4)
    opx|(n|)=ADD(opx|(n|),4)
  NEXT n|
  inp1$="INP1"
  inp2$="INP2"
  os|=1
  oos|=os|
  wavetosine(0)
  mainscreendraw
  fileopen!=FALSE       ! For grabber
  ON MENU BUTTON GOSUB capturemouse
RETURN
> PROCEDURE tidyupfmc                 !! Shut-down FMC program
  ~ModifyIDCMP(win%,0)
  @closefont(topaz11%)
  IF dfont_lib%<>0
    ~CloseLibrary(dfont_lib%)
  ENDIF
  IF fileopen!
    CLOSE #2
  ENDIF
  ON MENU BUTTON GOSUB 0
  ' CLOSEW #1
  ' CLOSES 1
RETURN
' --- MAIN SCREEN -------------------------------------------------------------
> PROCEDURE main                      !! MAIN LOOP
  LOCAL ss|,z|
  REPEAT
    REPEAT
      SLEEP
    UNTIL esc!=FALSE
    click
    SUB ym&,11
    '    prompt("")
    f|=0
    IF ym&>103 AND ym&<498                      ! Algorithm Area
      moveopbox
    ELSE IF ym&<118 AND ym&>80 AND xm&<520      ! Operator data parameters
      changeparam
    ENDIF                                       ! \/ \/ Option buttons
    IF xm&>=0 AND xm&<635 AND MOD(ADD(ym&,6),22)<20 AND ym&<79 AND ym&>-6
      mainoptions
    ENDIF
    IF gfl!=TRUE        ! screen need redrawing?
      mainscreendraw
      gfl!=FALSE
    ENDIF
  UNTIL qut!                     !------------ ENDPROC
RETURN
> PROCEDURE mainoptions               !! Buttons
  d%=MUL(4,DIV(xm&,105))+DIV(ADD(ym&,6),22)
  SELECT d%
  CASE 0            ! Reset Osc
    resetop(f|,FALSE)
  CASE 1            ! Delete Op
    prompt("Click on the operator to Delete.")
    whichop(f|)
    IF f|>0
      delop(f|)
    ENDIF
    prompt("")
  CASE 2            ! Insert Op
    prompt("Click on an operator for insertion position.")
    whichop(f|)
    IF f|>0
      newop(f|)
    ENDIF
    prompt("")
  CASE 3                ! Number Osc
    oos|=od(0)
    numberop
    IF oos|<>od(0)
      mainalgodraw
    ENDIF
  CASE 4                ! Help
    helpview
  CASE 5                ! Sample Sources
    samples
    gfl!=TRUE
  CASE 6                ! Waveform Sources
    waveedit
    gfl!=TRUE
  CASE 7                ! Envelopes
    editenv
    gfl!=TRUE
  CASE 9                ! Spectrum
    spectrum
    spec!=FALSE
    gfl!=TRUE
  CASE 10               ! Preview
    preview
    gfl!=TRUE
  CASE 11               ! Process
    process
  CASE 13               ! Quit
    prompt("Click it again to Quit.")
    click
    d%=MUL(4,DIV(xm&,105))+DIV(SUB(ym&,5),22)
    IF d%=13
      qut!=TRUE
    ENDIF
    prompt("")
  CASE 14               ! Load voice
    mainloadvoice
  CASE 15               ! Save Voice
    mainsavevoice
  CASE 17,21            ! Tuning
    masttun=MIN(MAX(-60,@paraminp("Input Tuning (semitones)",masttun,6)),60)
    mtun=2^(masttun/12) ! Is there other tuning? How?
    maininfodraw
  CASE 18,22            ! Sample File
    palette(&HCCC,&H0,&HFFF,&H0)
    rpath$=path$
    si$=path$
    path$=@fselect$("Sample Save Filename","OK",path$,TRUE)
    IF path$=""
      path$=rpath$
    ENDIF
    palette(&HAAA,&H0,&HFFF,&HDD0)
    maininfodraw
  CASE 19               ! Sample Len
    od(2)=@paraminp("Input new sample length",od(2),6)
    od(2)=MAX(8,od(2))
    maininfodraw
  CASE 23               ! 16-Bit toggle
    bit16!=NOT bit16!
    maininfodraw
  ENDSELECT
RETURN
> PROCEDURE operatorname(n&,VAR inp1$,inp2$)!Get operator name from type given
  SELECT n&
  CASE 1
    inp1$="MODi MIXi Source"
    inp2$="Generator / FM"
    ' CASE 2
    ' inp1$="MODi INPUT"
    ' inp2$="Pitch Modulation"
  CASE 5
    inp1$="MODi INPUT"
    inp2$="Amplitude Mod"
  CASE 10
    inp1$="INPa INPb"
    inp2$="Input Mixer"
  CASE 11
    inp1$="INPa INPb"
    inp2$="Balance Mixer"
  CASE 16
    inp1$="INPa INPb"
    inp2$="Splice Mixer"
  CASE 20
    inp1$=""
    inp2$="Pitch Controller"
  CASE 30
    inp1$="INPUT"
    inp2$="High Freq.Filter"
  CASE 35
    inp1$="INPUT"
    inp2$="Delay Gate"
  CASE 40
    inp1$="INPUT"
    inp2$="Threshold Clip"
  CASE 41
    inp1$="INPUT"
    inp2$="Clip Amplitude"
  CASE 42
    inp1$="INPUT"
    inp2$="Rectifier"
  DEFAULT
    inp1$=""
    inp2$="-- Do Nothing --"
  ENDSELECT
  inp2$=inp2$+SPACE$(16-LEN(inp2$))
RETURN
> PROCEDURE determax(os|,VAR maxn|)   !! Determine highest x available d%(os|,x)
  ss|=d%(os|,5)
  SELECT ss|
  CASE 1
    maxn|=10
  CASE 5,10,11,15,16
    maxn|=9
  CASE 30,35,40,41,42
    maxn|=8
  DEFAULT
    maxn|=7
  ENDSELECT
RETURN
> PROCEDURE changeparam               !! MainScreen: Change Op Data
  f!=FALSE
  n|=0
  determax(os|,maxn|)           ! How many parameters are valid for op-type?
  ADD xm&,26
  REPEAT                        ! Determine which parameter was selected
    INC n|
    IF xm&>=opx|(n|)*8+5 AND xm&<=opz|(n|)*8+7
      f!=TRUE
    ENDIF
  UNTIL f!=TRUE OR n|=11
  ' n|  Parameter       d%(os|,xxx)             ! MAPPING of parameters
  '  1  Type            5
  '  2  Freq            f(os|)
  '  3  Detune          2
  '  4  Phase           3
  '  5  OutL            4
  '  6  xPAR1 : Link1   6
  '  7  xPAR2 : Link2   7
  '  8  xPAR3 : Source  8
  '
  IF f!         ! if a parameter was selected (exception: Op-Type n|=50)
    IF n|>1 AND n|<maxn|          ! If a valid parameter was selected
      rt$="EditTable/Parameter Edit"
      prompt("")
      len|=opz|(n|)-opx|(n|)
      prompt("Operator "+STR$(os|)+": "+opm$(n|))
      TEXT opx|(n|)*8-20,113,STRING$(len|,"_")
      PRINT AT(opx|(n|)-2,10);
      DEC n|
      IF n|=2                      ! Input frequency
        f(os|)=@ipt(f(os|),len|,4,6)
        mainopdatadraw(os|)
      ELSE
        ot|=d%(os|,5)
        IF ot|=1 AND n|=8   ! op-type 1 (SigGen), SRC parameter ?
          srcpopupmenu(wv|)
          d%(os|,8)=wv|
        ELSE IF n|=1    ! change op-type
          optypeselect(f%)
          d%(os|,5)=f%
          n|=5
        ELSE
          IF n|>2 AND n|<6
            DEC n|
          ENDIF
          link!=FALSE             ! determine if link parameter
          IF (ot|=1 OR ot|=2 OR ot|=5 OR ot|=10 OR ot|=11 OR ot|=16) AND (n|=6 OR n|=7)
            link!=TRUE
          ELSE IF (ot|=30 OR ot|=35 OR ot|=40 OR ot|=42) AND (n|=6)
            link!=TRUE
          ENDIF
          IF link!                ! If link
            COLOR 3
            BOX ox&(os|),oy&(os|),ox&(os|)+bw&,oy&(os|)+bh&
            prompt("")
            prompt("Use which operator as input to this ? (Click on it)")
            whichop(f|)
            d%(os|,n|)=f|
          ELSE
            f%=@ipt(d%(os|,n|),len|,4,6)
            d%(os|,n|)=f%
          ENDIF !IF ot|=1
        ENDIF !IF link!
        IF n|>4 AND n|<9   ! Links or op-type altered?
          mainalgodraw
        ELSE
          mainopdatadraw(os|)
        ENDIF
        prompt("")
      ENDIF !(n|=2?)
    ENDIF ! 0<n<9
  ENDIF ! valid par.?
RETURN
> PROCEDURE optypeselect(VAR os%)     ! Pop-up (for OP parameter)
  LOCAL n&,y&,oname$,xm&,ym&,c&,yl&,nop&
  DIM n&(15)
  COLOR 0               ! Draw box
  nop&=12                       ! Box size
  yl&=nop&*14+144
  PBOX 20,130,160,yl&
  frame(20,130,160,yl&)
  RESTORE opnumbers
  y&=12
  COLOR 2
  FOR c&=0 TO nop&-1            ! draw list items
    READ n&
    operatorname(n&,dum$,oname$)
    n&(c&)=n&
    TEXT 26,y&+131,oname$
    ADD y&,14
  NEXT c&
  click
  SUB xm&,20
  SUB ym&,134
  IF xm&<160 AND ym&<nop&*14 AND xm&>0 AND ym&>0
    os&=ym& DIV 14
    GRAPHMODE 2
    PBOX 22,os&*14+134,158,os&*14+148
    REPEAT
    UNTIL MOUSEK=0
    PBOX 22,os&*14+134,158,os&*14+148
    GRAPHMODE 1
    os%=n&(os&)
  ENDIF
  opnumbers:
  DATA 0,1,5,10,11,16,20,30,35,40,41,42
  ERASE n&()
RETURN
> PROCEDURE srcpopupmenu(VAR choice|) ! Choose which Source (op. type 1,15)
  LOCAL owin%,n|,x&,y&,xo&,yo&,ct|
  DIM s|(32)
  xo&=100
  yo&=130
  srcframedraw          ! Draw requester
  sourcedone!=FALSE
  REPEAT
    click
    SUB ym&,yo&+12
    SUB xm&,xo&
    IF xm&>9 AND ym&>12 AND xm&<450 AND ym&<yh&-6
      IF ym&<71
        IF ((xm&-10) MOD 90)<80     ! Waveform
          choice|=(xm&-10) DIV 90
          srcframedraw          ! Draw requester
        ENDIF
      ELSE IF ym&>109            ! Sample
        n|=DIV(SUB(ym&,110),12)
        IF n|<ct| AND n|>=0
          choice|=s|(n|+1)
          srcframedraw          ! Draw requester
        ENDIF
      ENDIF
    ELSE IF xm&>457 AND xm&<507     ! Source Editing options
      IF ym&>10 AND ym&<31       !Edit
        src|=choice|
        waveedit
        mainscreendraw
        srcframedraw          ! Draw requester
      ELSE IF ym&>32 AND ym&<53  !Load
        src|=choice|
        waveload
        srcframedraw          ! Draw requester
      ELSE IF ym&>54 AND ym&<75  !Save
        src|=choice|
        wavesave
      ELSE IF ym&>76 AND ym&<103  !OK (Exit)
        sourcedone!=TRUE
      ELSE IF ym&>104 AND ym&<125  !New/Edit List
        samples
        mainscreendraw
        srcframedraw          ! Draw requester
      ENDIF
    ENDIF
  UNTIL sourcedone!
  ERASE s|()
  ym&=-100
  xm&=-100
RETURN
> PROCEDURE srcframedraw
  ' Use this procedure ONLY from within SrcPopupMenu
  '
  ' Determine number of samples, and highest numbered source available
  CLR ct|
  FOR n|=16 TO 47
    t$=s$(n|)
    IF fln%(n|)>0
      INC ct|
      s|(ct|)=n|
    ENDIF
  NEXT n|
  ' Do the drawing...
  yh&=130+MAX(ct|,1)*12
  COLOR 0
  PBOX xo&,yo&-1,xo&+530,yo&+yh&
  frame(xo&,yo&-1,xo&+530,yo&+yh&)
  '        ## Draw Waveform Sources
  COLOR 1
  TEXT xo&+10,yo&+15,"Waveform Sources"
  y&=23
  FOR n|=0 TO 4
    x&=MUL(90,n|)+10
    IF choice|=n|
      frame(xo&+x&-2,yo&+y&-2,xo&+x&+82,yo&+y&+62)
    ENDIF
    COLOR 1
    wavedraw(n|,0.125,xo&+x&,yo&+y&,240)
    BOX xo&+x&,yo&+y&,xo&+x&+80,yo&+y&+60
  NEXT n|
  block(xo&+458,yo&+23,"Edit",6,1,0)
  block(xo&+458,yo&+45,"Load",6,1,0)
  block(xo&+458,yo&+67,"Save",6,1,0)
  '        ## Draw Sample Sources
  COLOR 1
  BOX xo&+10,yo&+101,xo&+454,yo&+102
  BOX xo&+510,yo&+101,xo&+520,yo&+102
  TEXT xo&+10,yo&+115,"Sample Sources"
  FOR n|=1 TO ct|
    IF s|(n|)=choice| THEN
      COLOR 2
    ELSE
      COLOR 1
    ENDIF
    IF s|(n|)>=32 AND s|(n|)<48
      g$="16b "
    ELSE
      g$=" 8b "
    ENDIF
    TEXT xo&+10,n|*12+yo&+119,g$+RIGHT$(s$(s|(n|)),51)
  NEXT n|
  block(xo&+458,yo&+117,"New",6,1,0)
  frame(xo&+458,yo&+89,xo&+506,yo&+115)
  TEXT xo&+474,yo&+105,"OK"
RETURN
> PROCEDURE moveopbox                 !! Test, Grab & Move an Op in the Algorithm
  LOCAL oxx&,oyy&,z|,tf!,f!
  ADD ym&,11
  FOR z|=od(0) TO 1 STEP -1     ! Is a box held by mouse?
    IF xm&>ox&(z|) AND xm&<ADD(ox&(z|),bw&) AND ym&>oy&(z|) AND ym&<ADD(oy&(z|),bh&)
      f|=z|
    ENDIF
    EXIT IF f|>0
  NEXT z|
  IF f|>0                   ! If box held
    IF os|<>f|                  ! If not current operator
      os|=f|
      mainopactivate(os|)
      mainopdatadraw(os|)            ! redraw op parameters
    ENDIF
    MOUSE mx&,my&,mz&           ! getmouse *** change to ClickGetPos()
    px&=mx&-ox&(f|)
    py&=my&-oy&(f|)
    oxx&=xx&
    oyy&=yy&
    GRAPHMODE 2
    COLOR 3
    tf!=FALSE
    REPEAT                      ! Loop: if mouse moves, outline new position. Todo: msg not poll.
      MOUSE xx&,yy&,mz&
      IF yy&<>oyy& OR xx&<>oxx&
        xx&=MAX(4,MIN(636-bw&,xx&-px&))+px&
        yy&=MAX(124,MIN(476-bh&,yy&-py&))+py&
        IF tf!
          BOX SUB(oxx&,px&),SUB(oyy&,PRED(py&)),ADD(SUB(oxx&,px&),bw&),ADD(SUB(oyy&,py&),SUCC(bh&))
        ENDIF
        tf!=TRUE
        BOX SUB(xx&,px&),SUB(yy&,PRED(py&)),ADD(SUB(xx&,px&),bw&),ADD(SUB(yy&,py&),SUCC(bh&))
        oyy&=yy&
        oxx&=xx&
      ENDIF
    UNTIL MOUSEK=0
    GRAPHMODE 1
    f!=FALSE
    IF xx&<>mx& OR yy&<>my&     ! If box has been moved..
      ox&(f|)=SUB(xx&,px&)
      oy&(f|)=SUB(yy&,py&)
      f!=TRUE
      mainalgodraw
    ELSE
      mainopactivate(os|)
    ENDIF
  ENDIF
RETURN
> PROCEDURE mainopactivate(os|)       ! Activate and re-colour an operator (*)
  LOCAL n|,c|,o|,ox&,oy&
  ' GLOBAL: oos|     ! Previously active operator
  n|=0
  REPEAT
    INC n|
    IF n|=1
      o|=oos|
      oos|=os|
      c|=1
    ELSE
      o|=os|
      c|=2
    ENDIF
    IF o|<=od(0)
      ox&=ox&(o|)
      oy&=SUCC(oy&(o|))
      COLOR c|
      BOX ox&,oy&,ADD(ox&,bw&),ADD(oy&,bh&)
      BOX SUCC(ox&),SUCC(oy&),ADD(ox&,PRED(bw&)),ADD(oy&,PRED(bh&))
    ENDIF
  UNTIL n|=2
RETURN
> PROCEDURE mainscreendraw            !! Draw Main Screen (*)
  COLOR 0,0,0
  CLEARW #1
  promptx&=216
  palette(&HAAA,&H0,&HFFF,&HDD0)
  prompt("")
  maingadgdraw
  mainalgodraw
RETURN
> PROCEDURE maingadgdraw              ! Draw Main Screen Gadgets (*)
  LOCAL n|,x&,y&
  RESTORE gad ! See PROGDATA
  FOR n|=0 TO 15
    READ n$
    IF n$<>""
      x&=DIV(n|,4)*105
      y&=MOD(n|,4)*22+5
      block(x&,y&,n$,13,1,0)
    ENDIF
  NEXT n|
  frame(420,27,639,90)
  frame(0,117,639,502)
  maininfodraw
RETURN
> PROCEDURE maininfodraw              ! Show Tuning, Sample file, Sample Len (*)
  LOCAL l$
  IF bit16!
    l$="N "
  ELSE
    l$="FF"
  ENDIF
  COLOR 0
  PBOX 422,29,636,71
  COLOR 1
  TEXT 430,39,"Master Tune: "+LEFT$(STR$(masttun),9)
  TEXT 430,61,"Out: "+RIGHT$(path$,18)
  TEXT 430,83,"Len: "+STR$(od(2),6)+"  16-Bit: O"+l$
RETURN
> PROCEDURE maindataheaddraw(os|)     ! Show parameter names (*)
  operatorname(d%(os|,5),inp1$,inp2$)
  COLOR 0
  PBOX 8,91,640,104
  COLOR 1
  TEXT 12,101,"OSC TYPE             FREQUENCY DTUNE PHASE OUTL "+inp1$
RETURN
> PROCEDURE mainopdatadraw(qo|)       ! Show Operator data (*)
  LOCAL y&
  maindataheaddraw(qo|)
  y&=113
  COLOR 0
  PBOX 8,104,639,116
  COLOR 1
  determax(qo|,maxn|)
  operatorname(d%(os|,5),inp1$,inp2$)
  TEXT 12,y&,STR$(qo|,3)+" "+inp2$+STR$(f(qo|),10)+STR$(d%(qo|,2),6)+STR$(d%(qo|,3),6)+STR$(d%(qo|,4),5)
  IF maxn|>7
    TEXT 388,y&,STR$(d%(qo|,6),4)
    IF maxn|>8
      TEXT 436,y&,STR$(d%(qo|,7),4)
      IF maxn|>9
        SELECT d%(qo|,8)
        CASE 0 TO 4
          src$="Wave "+CHR$(d%(qo|,8)+48)
          wavedraw(d%(qo|,8),0.096,534,100,42) ! Wave
        CASE 16 TO 48
          src$=RIGHT$(s$(d%(qo|,8)),20)
        ENDSELECT
        TEXT 476,y&,src$
      ENDIF
    ENDIF
  ENDIF
RETURN
' --- ALGORITHM-ASSOCIATED PROCS ----------------------------------------------
> PROCEDURE mainalgodraw              ! Draw graphic algorithm & data (*)
  LOCAL md|,n,mx|,n|,t|,xp&,ox&,oy&,px&,py&,mxx&,mxy&
  COLOR 0,0,0
  PBOX 3,121,637,498
  mainopdatadraw(os|)
  FOR n|=1 TO od(0)
    n=n|*3
    md|=d%(n|,6)
    t|=d%(n|,5)
    mxx&=ox&(n|)
    mxy&=oy&(n|)
    ' ***
    IF md|>0 AND md|<=od(0) AND t|<>15  ! Right-side link (param #6)
      xp&=10
      ox&=ox&(md|)
      oy&=oy&(md|)
      IF t|=64
        COLOR 1
      ELSE
        COLOR 2
      ENDIF
      PLOT ox&+bw&*0.8,oy&+bh&*0.3
      IF md|<n|
        DEFLINE &X1100110011001100
      ENDIF
      '      IF md|=n|         ! Connect to self
      '        LINE ox&+bw&,oy&+bh&*0.75,ox&+bw&+xp&,oy&+bh&*0.75
      '        DRAW  TO ox&+bw&+xp&,oy&+bh&*0.25
      '        DRAW  TO ox&+bw&,oy&+bh&*0.25
      '      ELSE
      DRAW  TO ox&+bw&*0.8,oy&+bh&*1.5
      py&=mxy&-bh&*0.3-2
      IF oy&>mxy&-bh&
        IF ox&>mxx&+bw&
          px&=mxx&+bw&+xp&
          DRAW  TO ox&-xp&,oy&+bh&*1.5
        ELSE IF ox&+bw&<mxx&
          px&=mxx&-xp&
          DRAW  TO ox&+bw&+xp&,oy&+bh&*1.5
        ELSE
          px&=mxx&+bw&+xp&
          DRAW  TO ox&+bw&+xp&,oy&+bh&*1.5
        ENDIF
      ELSE
        px&=mxx&+bw&*0.8
      ENDIF
      DRAW  TO px&,py&
      DRAW  TO mxx&+bw&*0.8,py&
      DRAW  TO mxx&+bw&*0.8,mxy&+bh&*0.3
      '      ENDIF
      DEFLINE 65535
    ENDIF       !(right-side #6)
    ' ***
    mx|=d%(n|,7)
    xp&=8
    IF mx|>0 AND mx|<=od(0) AND t|<>30 AND t|<>15 ! Left-side link (#7)
      ox&=ox&(mx|)
      oy&=SUCC(oy&(mx|))
      COLOR 1
      PLOT ox&+bw&*0.2,oy&+bh&*0.5
      IF mx|<n|     ! is feedback
        DEFLINE &X1100110011001100
      ENDIF
      '      IF mx|=n|
      '        LINE ox&,oy&+bh&*0.75,ox&-8,oy&+bh&*0.75
      '        DRAW  TO ox&-8,oy&+bh&*0.25
      '        DRAW  TO ox&,oy&+bh&*0.25
      '      ELSE
      DRAW  TO ox&+bw&*0.2,oy&+bh&*1.5-5
      py&=mxy&-bh&*0.5
      IF oy&>mxy&-bh&
        IF ox&>mxx&+bw&
          px&=mxx&+bw&+xp&
          DRAW  TO ox&-xp&-4,oy&+bh&*1.5-5
        ELSE IF ox&+bw&<mxx&
          px&=mxx&-xp&-4
          DRAW  TO ox&+bw&+xp&,oy&+bh&*1.5-5
        ELSE
          px&=mxx&+bw&+xp&
          DRAW  TO ox&+bw&+xp&,oy&+bh&*1.5-5
        ENDIF
      ELSE
        px&=mxx&+bw&*0.2
      ENDIF
      DRAW  TO px&,py&
      DRAW  TO mxx&+bw&*0.2,py&
      DRAW  TO mxx&+bw&*0.2,mxy&+bh&*0.5
    ENDIF
    DEFLINE 65535
    '   ENDIF
  NEXT n|
  FOR n|=1 TO od(0)
    ox&=ox&(n|)
    oy&=SUCC(oy&(n|))
    IF n|=os|
      c|=2
    ELSE
      c|=1
    ENDIF
    COLOR c|
    PBOX ox&,oy&,ox&+bw&,oy&+bh&
    COLOR 0
    PBOX ADD(ox&,2),ADD(oy&,2),SUB(ADD(ox&,bw&),2),SUB(ADD(oy&,bh&),2)
    COLOR 1
    TEXT ADD(ox&,11),ADD(oy&,24),STR$(n|,2)
    SELECT d%(n|,5)
    CASE 1
      t$="GenM"
    CASE 2
      t$="LFO"
    CASE 5
      t$=" AM"
    CASE 10
      t$="=MIX"
    CASE 11
      t$="BMIX"
    CASE 16
      t$="ISPL"
    CASE 20
      t$="PITC"
    CASE 30
      t$="HFIL"
    CASE 35
      t$="DELY"
    CASE 40
      t$="TSUB"
    CASE 41
      t$="CLIP"
    CASE 42
      t$="RECT"
    DEFAULT
      t$="----"
    ENDSELECT
    TEXT ADD(ox&,3),ADD(oy&,12),t$
  NEXT n|
  oos|=os|      ! Set Global for mainopactivate()
RETURN
> PROCEDURE resetop(f|,pos!)          ! Reset operator to default data (not links)
  ' IF pos!=TRUE, reset operator f|, and set coords.
  ' IF     FALSE, User-select from Algo area, No coord reset.
  LOCAL p|,m|,n|
  IF pos!
    p|=f|-1
    oy&(f|)=SUB(244,MUL(DIV(p|,10),60))
    ox&(f|)=ADD(MUL(MOD(p|,10),56),20)
  ELSE
    prompt("Reset which operator ? (Click twice on it)")
    esc!=FALSE
    whichop(f|)
  ENDIF
  IF f|>0
    RESTORE vcdat
    READ f(f|)
    FOR m|=2 TO 8
      READ d%(f|,m|)
    NEXT m|
    os|=f|
    IF os|>0 AND os|<=od(0)     ! If visible
      ' RESTORE vcdat
      ' READ f(os|)
      ' FOR n|=2 TO 8
      '  READ d%(os|,n|)
      ' NEXT n|
      envdatareset(os|)
      IF NOT pos!
        mainopdatadraw(os|)
      ENDIF
    ENDIF
  ENDIF
  yt|=255
RETURN
> PROCEDURE whichop(VAR f|)           ! Test for mouse, return operator
  click
  FOR z|=od(0) TO 1 STEP -1
    IF xm&>=ox&(z|) AND xm&<=ADD(ox&(z|),bw&) AND ym&>=oy&(z|) AND ym&<=ADD(oy&(z|),bh&)
      f|=z|
    ENDIF
    EXIT IF f|>0
  NEXT z|
RETURN
> PROCEDURE numberop                  ! Set Number of operators to be used
  REPEAT
    od(0)=MIN(@paraminp("Input number of operators",od(0),2),no|)
  UNTIL od(0)>=0 AND od(0)<25
  maininfodraw          ! *** WHY ?
RETURN
> PROCEDURE newop(qosc|)              ! Insert a new operator into algorithm
  LOCAL n|,m|,n%
  IF od(0)<24
    FOR m|=od(0) DOWNTO qosc|
      n|=ADD(m|,1)              ! Insert new operator
      f(n|)=f(m|)
      ox&(n|)=ox&(m|)
      oy&(n|)=oy&(m|)
      FOR n%=0 TO 16
        et(n|,n%)=et(m|,n%)     ! envelope stages
        ep(n|,n%)=ep(m|,n%)     ! "
        IF n%<>16
          d%(n|,n%)=d%(m|,n%)   ! operator data parameters
        ENDIF
      NEXT n%
      IF d%(n|,7)>=qosc|        ! alter links to compensate
        ADD d%(n|,7),1
      ENDIF
      IF d%(n|,6)>=qosc|        ! "
        ADD d%(n|,6),1
      ENDIF
    NEXT m|
    INC od(0)                   ! Position new operator
    ADD ox&(qosc|),18
    ADD oy&(qosc|),12
    d%(qosc|,6)=0               ! Remove links
    d%(qosc|,7)=0
    mainalgodraw                ! redraw algorithm
  ENDIF
RETURN
> PROCEDURE delop(qosc|)              ! Remove operator from algorithm
  LOCAL n|,n%
  IF od(0)>1    ! If not the last OP
    FOR n|=qosc| TO od(0)-1
      m|=ADD(n|,1)
      f(n|)=f(m|)
      ox&(n|)=ox&(m|)           ! coords
      oy&(n|)=oy&(m|)
      FOR n%=0 TO 16
        et(n|,n%)=et(m|,n%)     ! envelope stages
        ep(n|,n%)=ep(m|,n%)     ! "
        IF n%<>16
          d%(n|,n%)=d%(m|,n%)   ! operator data parameters
        ENDIF
      NEXT n%
      IF d%(n|,7)>=qosc|        ! alter links to compensate
        DEC d%(n|,7)
      ENDIF
      IF d%(n|,6)>=qosc|        ! "
        DEC d%(n|,6)
      ENDIF
    NEXT n|
    DEC od(0)
    mainalgodraw                ! redraw algorithm
  ENDIF
RETURN
' --- ENVELOPES ---------------------------------------------------------------
PROCEDURE editenv                   ! Envelope Edit (*)
  LOCAL ee|,n|,n&,ym&,xm&,xt|,yt|,ef!,qenv!
  envscreendraw
  copyfromenv!=FALSE
  qenv!=FALSE
  REPEAT        ! Control LOOP
    COLOR 0             ! Current OP on OP-Select line
    BOX 38,283,630,284
    BOX 38,267,630,268
    COLOR 3
    n&=ADD(MUL(ee|,24),16)
    BOX n&,283,ADD(n&,16),284
    BOX n&,267,ADD(n&,16),268
    click               ! Mouse
    ef!=FALSE
    IF xm&>240 AND ym&>142 AND ym&<250    ! ------- Options
      d%=MUL(5,DIV(xm&-250,132))+DIV(SUB(ym&,143),22)
      envrangeaction!=FALSE
      SELECT d%
      CASE 0,1,5,6     ! Next click acted on if inside envelope graphic/table
        envrangeaction!=TRUE
        envrangeaction%=d%
        SELECT d%
        CASE 0
          prompt("Click on the new 'End Range' - stages will stretch...")
        CASE 1
          prompt("Click on the new 'Start Range' - stages will move...")
        CASE 5
          prompt("Click where the new stage is to be...")
        CASE 6
          prompt("Click on the stage to be removed...")
        ENDSELECT
      CASE 2                    ! Cancel Range
        envrangestart=0
        envrangeend=0
        envgraphdraw
        envrangeinfo(envrangestart,envrangeend)
      CASE 10                   ! Exit
        qenv!=TRUE
      CASE 11                   ! Envelope Edit: Reset
        envdatareset(ee|)
        envscreendraw
      CASE 12                   ! Copy Env From...
        prompt("Copy which envelope (choose from the OP bar)")
        click               ! Mouse
        prompt("")
        ef!=FALSE
        copyfromenv!=TRUE  ! will be acted on if next click in on op.bar
      CASE 13                   ! Set Min.Level
      CASE 14                   ! Set Max.Level
      ENDSELECT
    ELSE IF ym&<289 AND ym&>262               ! ---- User: OP-Select (bar)
      n&=DIV(SUB(xm&,16),24)
      IF n&>0 AND n&<=od(0)
        envto|=ee|
        FOR n|=1 TO 16
          IF copyfromenv!        ! If Copy Env From... option was selected
            et(envto|,n|)=et(n&,n|)
            ep(envto|,n|)=ep(n&,n|)
          ENDIF
          ee|=n&
          envdatatabledraw(n|)
        NEXT n|
        copyfromenv!=FALSE
      ENDIF
      ef!=TRUE
    ELSE IF ym&>13 AND ym&<243 AND xm&<220    ! ---- User: Change table
      st|=DIV(SUB(ym&,23),13)
      IF st|>0 AND st|<17
        IF xt|>12 AND xt|<20
          ef!=TRUE
          prompt(" Stage "+STR$(st|)+" TIME (% of length) >")
          PRINT AT(59,1);
          et(ee|,st|)=@ipt(et(ee|,st|)-st|*0.0001,6,4,9)+st|*0.0001
          envdatatabledraw(st|)
        ELSE IF xt|>19 AND xt|<28
          ef!=TRUE
          prompt("  Stage "+STR$(st|)+" LEVEL (0 to 100%) >")
          PRINT AT(59,1);
          ep(ee|,st|)=@ipt(ep(ee|,st|),6,4,9)
          envdatatabledraw(st|)
        ENDIF
      ENDIF
    ELSE IF ym&>285                 ! ---- User: Graphic Edit
      IF envrangeaction!
        SELECT envrangeaction%
        CASE 0          ! --- Scale Time
          envpc=(xm&-35)/6
          IF ABS(envrangeend-envrengestart)=>0.001    ! avoid 'div 0'
            envscalefactor=(envpc-envrangestart)/(envrangeend-envrangestart)
          ELSE
            envscalefactor=0.001
          ENDIF
          ' Change envelope
          FOR n|=1 TO 16
            IF et(ee|,n|)>=envrangestart AND et(ee|,n|)<=envrangeend
              et(ee|,n|)=(et(ee|,n|)-envrangestart)*envscalefactor+envrangestart  ! add difference to move stage
              envdatatabledraw(n|)
            ENDIF
          NEXT n|
          envrangeend=(envrangeend-envrangestart)*envscalefactor+envrangestart      ! set new end,
          envrangeend=MAX(MIN(100,envrangeend),0)
          envgraphdraw                       ! show graph and range
          envrangeinfo(envrangestart,envrangeend)
        CASE 1          ! --- Move Time
          envpc=(xm&-35)/6      ! new 'start range', in range -0.16 to 100%
          envpc=envpc-envrangestart   ! common difference of stages to new pos
          ' Change envelope
          FOR n|=1 TO 16
            IF et(ee|,n|)>=envrangestart AND et(ee|,n|)<=envrangeend
              et(ee|,n|)=et(ee|,n|)+envpc  ! add difference to move stage
              envdatatabledraw(n|)
            ENDIF
          NEXT n|
          envrangestart=envrangestart+envpc  ! set new start,
          envrangeend=envrangeend+envpc      ! set new end,
          envrangestart=MAX(MIN(100,envrangestart),0)
          envrangeend=MAX(MIN(100,envrangeend),0)
          envgraphdraw                       ! show graph and range
          envrangeinfo(envrangestart,envrangeend)
        CASE 5          ! Insert New
          envpc=(xm&-35)/6
          n&=0
          st|=0
          envstageout!=FALSE
          REPEAT
            INC n&
            IF et(ee|,n&)>envpc
              st|=n&
              envstageout!=TRUE
            ENDIF
          UNTIL (n&=16) OR envstageout!=TRUE
          envinsertstage(ee|,st|,envpc,397-ym&)
        CASE 6          ! Remove
          envwhichstage(ee|,xm&,ym&,st|)
          envremovestage(ee|,st|)
        ENDSELECT
        envrangeaction!=FALSE
      ELSE
        envwhichstage(ee|,xm&,ym&,st|)
        IF st|>0
          prompt("Moving stage "+STR$(st|)+" (drag to change time/level)")
          t=MAX(0,et(ee|,st|))
          p=ep(ee|,st|)
          PBOX t*6+31,394-p,t*6+37,400-p
          first|=MAX(0,st|-1)
          last|=MIN(16,st|+1)
          FOR n|=1 TO 2
            PLOT 34,397
            ti=MAX(0,et(ee|,first|))
            FOR sta|=first| TO last|
              envstagedraw(ee|,sta|,2,sta|=first|)
            NEXT sta|
            '
          NEXT n|
          REPEAT
            MOUSE xm&,ym&,bm&
            xm&=SUB(MIN(MAX(34,xm&),635),35)
            ym&=MAX(MIN(497,ym&),297)
            et(ee|,st|)=xm&/6+st|*0.0001
            ep(ee|,st|)=397-ym&
            envdatatabledraw(st|)
            '  clip(34,306,636,506,0,0)
            FOR n|=1 TO 2
              IF n|=2
                VSYNC
                VSYNC
              ENDIF
              PLOT 34,397
              ti=MAX(0,et(ee|,first|))
              FOR sta|=first| TO last|
                envstagedraw(ee|,sta|,2,sta|=first|)
              NEXT sta|
              '
            NEXT n|
          UNTIL bm&=0
          ef!=TRUE
        ELSE            ! drag mouse to select range
          envrangestart=(xm&-35)/6
          envrangestart=MAX(MIN(100,envrangestart),0)
          envpc=envrangestart
          prompt("Now drag the mouse to select a range")
          REPEAT
            clickgetpos(xm&,ym&,xt|,yt|)
            envrangeend=(xm&-35)/6
            envrangeend=MAX(MIN(100,envrangeend),0)
            IF envpc<>envrangeend
              GRAPHMODE 2
              PBOX envrangestart*6+35,297,envrangeend*6+35,497
              PBOX envrangestart*6+35,297,envpc*6+35,497
              GRAPHMODE 1
              ' prompt("Selecting Range "+STR$(ROUND(envrangestart,2))+" to "+STR$(ROUND(envrangeend,2)))
              envrangeinfo(envrangestart,envrangeend)
              envpc=envrangeend
            ENDIF
          UNTIL MOUSEK=0
          ef!=TRUE
          IF envrangeend<envrangestart
            SWAP envrangeend,envrangestart
          ENDIF
        ENDIF
        envrangeinfo(envrangestart,envrangeend)
        prompt("")
      ENDIF
    ENDIF
    IF ef!=TRUE
      envgraphdraw
    ENDIF
  UNTIL qenv!=TRUE
RETURN
> PROCEDURE envinsertstage(ee|,st|,et,ep)
  IF st|>0
    FOR n&=15 DOWNTO st|
      ep(ee|,n&+1)=ep(ee|,n&)
      et(ee|,n&+1)=et(ee|,n&)
      envdatatabledraw(n&+1)
    NEXT n&
    ep(ee|,st|)=ep
    et(ee|,st|)=et
    envdatatabledraw(st|)
    prompt("New stage now inserted at "+STR$(st|))
    envgraphdraw
  ELSE
    prompt("Cancelled")
  ENDIF
RETURN
> PROCEDURE envremovestage(ee|,st|)
  IF st|>0
    FOR n&=st| TO 15
      ep(ee|,n&)=ep(ee|,n&+1)
      et(ee|,n&)=et(ee|,n&+1)
      envdatatabledraw(n&)
    NEXT n&
    ep(ee|,16)=0
    et(ee|,16)=100
    envdatatabledraw(16)
    prompt("Stage "+STR$(st|)+" removed")
    envgraphdraw
  ELSE
    prompt("Cancelled")
  ENDIF
RETURN
> PROCEDURE envscreendraw             ! Draw Envelope Editing screen (*)
  LOCAL x&,y&,rows&,cols&,numcols&
  promptx&=230
  COLOR 0
  CLEARW #1
  frame(30,5,221,260)           ! Table
  frame(30,263,639,288)         ! OP-Select Line
  TEXT 8,279,"OP"
  TEXT 40,279,LEFT$(" 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24",MUL(od(0),3))
  ee|=os|
  envgraphdraw                  ! Envelope graph
  frame(245,123,375,260)
  TEXT 250,135,"Range"
  frame(377,123,507,260)
  TEXT 382,135,"Stage"
  frame(509,123,639,260)
  TEXT 514,135,"Envelope Edit"
  envscreendat:
  DATA "Scale Time ��","Move Time ��","Cancel Range",,
  DATA "Insert New",Remove,,,
  DATA EXIT,Reset Env,Copy From..,"Min.Level _�_","Max.Level ���"
  RESTORE envscreendat          ! Control gadgets
  FOR n|=0 TO 14
    READ n$
    IF n$<>""
      x&=DIV(n|,5)*132+250
      y&=MOD(n|,5)*22+143
      block(x&,y&,n$,15,1,0)
    ENDIF
  NEXT n|
  COLOR 1                       ! Table
  TEXT 48,27,"STAGE  TIME   LEVEL"
  ' TEXT 370,239,"COPY FROM"
  ' TEXT 306,239,"RESET"
  ' TEXT 250,239,"EXIT"
  ' frame(240,221,290,250)
  ' frame(300,221,350,250)
  ' frame(360,221,450,250)
  FOR n|=1 TO 16
    envdatatabledraw(n|)
  NEXT n|
RETURN
> PROCEDURE envdatatabledraw(qw|)     ! Show Envelope stage (numbers) (*)
  LOCAL qy&
  qy&=ADD(MUL(qw|,13),34)
  COLOR 1
  TEXT 60,qy&,STR$(qw|,2)
  TEXT 92,qy&,STR$(et(ee|,qw|)+qw|*0.0001,5)
  TEXT 156,qy&,STR$(ep(ee|,qw|),5)
RETURN
> PROCEDURE envgraphdraw              ! Plot Envelope (graphic) (*)
  LOCAL n|,st|,t,op,ti
  COLOR 0
  PBOX 30,293,638,501
  frame(30,293,638,501)
  COLOR 2
  PBOX envrangestart*6+35,297,envrangeend*6+35,497
  IF (envrangestart+2)<envrangeend
    PBOX envrangestart*6+36,297,envrangeend*6+34,497
  ENDIF
  COLOR 1
  FOR n|=0 TO 4
    LINE 34,ADD(297,MUL(n|,50)),634,ADD(297,MUL(n|,50))
    LINE ADD(34,MUL(n|,150)),297,ADD(34,MUL(n|,150)),497
    TEXT -4,SUB(495,MUL(n|,50)),STR$(SUB(MUL(n|,50),100),4)
  NEXT n|
  COLOR 3
  op=397-ep(ee|,1)
  PLOT 34,397
  ' clip(34,311,636,511,0,0)
  ti=0
  FOR st|=1 TO 16
    envstagedraw(ee|,st|,1,FALSE)
  NEXT st|
  '  normclip
RETURN
> PROCEDURE envstagedraw(ee|,st|,mode|,first!) ! Draw single stage (*)
  LOCAL t,p,op
  t=MAX(0,et(ee|,st|))
  p=ep(ee|,st|)
  GRAPHMODE mode|
  COLOR 3
  IF t>ti
    ti=t
  ENDIF
  IF first!
    PLOT ti*6+34,397-p
  ELSE
    DRAW  TO ti*6+34,397-p
  ENDIF
  IF st|<>0 AND mode|=1
    COLOR 1
    BOX t*6+31,394-p,t*6+37,400-p
    COLOR 2
    BOX t*6+30,393-p,t*6+38,401-p
  ENDIF
  op=397-p
  PLOT ti*6+34,op
  GRAPHMODE 1
RETURN
> PROCEDURE envrangeinfo(envrangestart,envrangeend)
  COLOR 1
  TEXT 250,221,"Start:"+STR$(envrangestart,5)
  TEXT 250,237,"  End:"+STR$(envrangeend,5)
RETURN
> PROCEDURE envwhichstage(ee|,xm&,ym&,VAR st|) ! Test for stage-'handle' grab(*)
  LOCAL t,p,n|,found!
  n|=0
  st|=0
  REPEAT
    INC st|
    t=MAX(0,et(ee|,st|))*6
    p=ep(ee|,st|)
    IF xm&-29>t AND xm&-39<t AND ym&+p>392 AND ym&+p<402
      found!=TRUE
    ENDIF
  UNTIL st|=16 OR found!
  IF NOT found!
    st|=0
  ENDIF
RETURN
> PROCEDURE envdatareset(ee|)         ! Reset an envelope to default |~~~|
  LOCAL m|
  RESTORE envp
  FOR m|=1 TO 16
    READ et(ee|,m|)
    READ ep(ee|,m|)
    et(ee|,m|)=et(ee|,m|)+m|*0.0001
  NEXT m|
RETURN
' --- STORAGE -----------------------------------------------------------------
> PROCEDURE mainsavevoice             ! Save Voice Patch
  prompt("")
  si$=otp$
  palette(&HCCC,&H0,&HFFF,&H0)
  tpath$=@fselect$("Save Current Voice","SAVE",otp$,TRUE)
  palette(&HAAA,&H0,&HFFF,&HDD0)
  IF ipt!=TRUE
    otp$=tpath$
    prompt("")
    prompt("SAVING to "+tpath$)
    OPEN "O",#4,tpath$
    PRINT #4,"FMCD"+MKI$(104);
    PRINT #4,"SCHT"+MKI$(2)+MKI$(scnht%)+"ODAT"+MKI$(128);
    FOR n|=0 TO 15
      PRINT #4,MKD$(od(n|));
    NEXT n|
    ln%=od(0)
    PRINT #4,"FREQ"+MKI$(MUL(ln%,8));
    FOR n|=1 TO ln%
      PRINT #4,MKD$(f(n|));
    NEXT n|
    PRINT #4,"OSCD"+MKI$(ln%*68);
    FOR n|=1 TO ln%
      PRINT #4,MKI$(ox&(n|));
      PRINT #4,MKI$(oy&(n|));
      FOR m|=0 TO 15
        PRINT #4,MKL$(d%(n|,m|));
      NEXT m|
    NEXT n|
    PRINT #4,"VENV"+MKI$(MUL(ln%,256));
    FOR n|=1 TO ln%
      FOR m|=1 TO 16
        PRINT #4,MKD$(et(n|,m|));
        PRINT #4,MKD$(ep(n|,m|));
      NEXT m|
    NEXT n|
    DIM ttt!(16)
    l&=0
    tt%=0
    FOR m|=16 TO 47
      s$=s$(m|)
      IF s$<>""
        s$=s$+SPACE$(MAX(0,80-LEN(s$)))
        PRINT #4,"SFIL"+MKI$(81);
        OUT #4,m|
        PRINT #4,s$;
        PRINT #4,"SLEN"+MKI$(5);
        OUT #4,m|
        PRINT #4,MKL$(fln%(m|));
      ENDIF
    NEXT m|
    FOR m|=1 TO ln%     !Count and note the waveforms used in algorithm
      IF d%(m|,5)=1
        t|=d%(m|,8)
        IF t|<5
          IF ttt!(t|)=FALSE
            INC tt%
            ttt!(t|)=TRUE
          ENDIF
        ENDIF
      ENDIF
    NEXT m|
    PRINT #4,"WAVE"+MKI$(MUL(tt%,1281));
    FOR m|=0 TO 15
      IF ttt!(m|)=TRUE
        OUT #4,m|
        FOR n&=0 TO 639
          PRINT #4,MKI$(tab(m|,n&)*128+960.501);
        NEXT n&
      ENDIF
    NEXT m|
    ERASE ttt!()
    PRINT #4,"EOF!"+CHR$(0)+CHR$(0);
    CLOSE #4
    prompt("SAVED "+tpath$)
  ENDIF
  palette(&HAAA,&H0,&HFFF,&HDD0)
RETURN
> PROCEDURE mainloadvoice             ! Load Voice Patch
  prompt("")
  si$=otp$
  palette(&HCCC,&H0,&HFFF,&H0)
  tpath$=@fselect$("Load New Voice","LOAD",otp$,FALSE)
  palette(&HAAA,&H0,&HFFF,&HDD0)
  IF NOT EXIST(tpath$)
    prompt("File does not exist.")
    ipt!=FALSE
  ENDIF
  IF ipt!=TRUE
    otp$=tpath$
    OPEN "I",#4,tpath$
    qf!=FALSE
    id$=INPUT$(4,#4)
    IF id$="FMCD"
      ver%=CVI(INPUT$(2,#4))
      ms$="Loaded FMC file - from FMC v"+STR$(ver%*0.01)
      ptr%=6
      REPEAT
        SEEK #4,ptr%
        hunk$=INPUT$(4,#4)
        siz%=CVI(INPUT$(2,#4))
        ADD ptr%,ADD(siz%,6)
        '        PRINT "HUNK: ";hunk$;"   Size:";siz%
        SELECT hunk$
        CASE "SCHT"
          scnht%=CVI(INPUT$(2,#4))
        CASE "ODAT"
          FOR n|=0 TO 15
            od(n|)=CVD(INPUT$(8,#4))
          NEXT n|
          ln%=od(0)
        CASE "FREQ"
          FOR n|=1 TO ln%
            f(n|)=CVD(INPUT$(8,#4))
          NEXT n|
        CASE "SFIL"
          m|=INP(#4)
          s$=INPUT$(80,#4)
          n|=80
          REPEAT
            EXIT IF MID$(s$,n|,1)<>" "
            DEC n|
          UNTIL n|=0
          s$(m|)=LEFT$(s$,n|)
        CASE "SLEN"
          n|=INP(#4)
          fln%(n|)=CVL(INPUT$(4,#4))
        CASE "OSCD"
          FOR n|=1 TO ln%
            ox&(n|)=CVI(INPUT$(2,#4))
            oy&(n|)=CVI(INPUT$(2,#4))
            FOR m|=0 TO 15
              d%(n|,m|)=CVL(INPUT$(4,#4))
            NEXT m|
          NEXT n|
        CASE "VENV"
          FOR n|=1 TO ln%
            FOR m|=1 TO 16
              et(n|,m|)=CVD(INPUT$(8,#4))
              ep(n|,m|)=CVD(INPUT$(8,#4))
            NEXT m|
          NEXT n|
        CASE "WAVE"
          n|=DIV(siz%,1281)
          FOR a|=1 TO n|
            t|=INP(#4)
            IF t|<>120
              FOR n&=0 TO 639
                tab(t|,n&)=(CVI(INPUT$(2,#4))-960.499)/128  ! todo: reals
              NEXT n&
            ENDIF
          NEXT a|
        CASE "EOF!"
          qf!=TRUE
        DEFAULT
          '          RELSEEK #4,siz%
        ENDSELECT
      UNTIL qf!=TRUE
    ELSE
      ms$="Not an FMC file!"
    ENDIF
    CLOSE #4
    mes$=ms$
    palette(&HAAA,&H0,&HFFF,&HDD0)
    mainscreendraw
    prompt(ms$)
  ENDIF
RETURN
' --- HELP --------------------------------------------------------------------
> PROCEDURE helpview                  ! Helpfile Viewer main proc. (*)
  CLEARW #1
  DIM t$(50),yp&(50)   !,p%(50)
  '  p%(0)=50
  op|=0
  IF EXIST(dcmd$+help$+".helpfile")
    hel$=dcmd$+help$+".helpfile"
  ENDIF
  IF EXIST(hel$)
    CLEARW #1
    PRINT AT(1,1);
    palette(&HAAA,&H0,&HCCC,&HAAA)
    OPEN "I",#4,hel$
    helpnewpage
    lc%=32000
    GRAPHMODE 0
    qf!=FALSE
    WHILE qf!=FALSE AND NOT EOF(#4)
      LINE INPUT #4,n$
      IF ASC(n$)=47                        ! /    (Start of a subject)
        n$="*S"
      ENDIF
      IF ASC(n$)<>42                       !      (Normal text)
        TEXT p%,x%+20,n$
        ADD x%,t%
        ADD x%,a%
        IF x%>498
          n$="*P"
        ENDIF
      ELSE                                 ! *    (* commands)
        c|=ASC(MID$(n$,2,1))
        SELECT c|
        CASE 70 ! *F
          CLOSE #4
          f$=MID$(n$,3)
          IF RIGHT$(f$,1)=CHR$(13)
            f$=LEFT$(f$,LEN(f$)-1)
          ENDIF
          IF EXIST(dcmd$+f$+".helpfile")
            help$=f$
            OPEN "I",#4,dcmd$+help$+".helpfile"
            helpnewpage
            lc%=32000
            op|=0
          ELSE
            helpnewpage
            TEXT 200,200,"*"+f$+"*     File not found - click."
            click
            qf!=TRUE
          ENDIF
        CASE 73 ! *I
          n%=VAL(MID$(n$,3))
          helploadindex
          click
          SUB ym&,8
          m|=0
          REPEAT
            INC m|
          UNTIL (ym&>yp&(m|) AND ym&<yp&(m|)+14 AND yp&(m|)<>0) OR m|=40
          IF m|<40
            op|=m|
            GRAPHMODE 2
            COLOR 3
            PBOX 0,yp&(m|)+8,640,yp&(m|)+22
            GRAPHMODE 0
            COLOR 1
            palette(&HAAA,&H0,&HCCC,&H800)
            IF RIGHT$(t$(m|),1)=CHR$(13)
              t$(m|)=LEFT$(t$(m|),LEN(t$(m|))-1)
            ENDIF
            helpfilefind("/"+t$(m|)+"/")
            palette(&HAAA,&H0,&HCCC,&HAAA)
            lc%=0
            helpnewpage
            REPEAT
            UNTIL INKEY$=""
          ELSE
            SEEK #4,0
            qf!=TRUE
          ENDIF
        CASE 76 ! *L
          a%=VAL(MID$(n$,3))
        CASE 80 ! *P
          COLOR 2,0
          TEXT 196,501,"** Click to continue text... **"
          click
          helpnewpage
        CASE 83 ! *S
          COLOR 2,0
          TEXT 184,501,"Click to return to the Help Index"
          click
          helpnewpage
          SEEK #4,0
        CASE 88 ! *X
          p%=VAL(MID$(n$,3))
        ENDSELECT
      ENDIF
    WEND
    CLOSE #4
  ELSE
    TEXT 20,21,"File not found  -  Click to return to main screen"
    click
  ENDIF
  GRAPHMODE 1
  ERASE t$(),yp&()    !,p%()
  gfl!=TRUE
RETURN
> PROCEDURE helploadindex             ! Help: Load and display an index
  FOR o%=1 TO 40
    ' p%(o%)=0
    yp&(o%)=0
  NEXT o%
  FOR o%=1 TO n%
    LINE INPUT #4,t$(o%)
    yp&(o%)=x%+2
    IF o%<40
      TEXT p%,x%+20,t$(o%)
      ADD x%,a%
      ADD x%,t%
    ENDIF
  NEXT o%
RETURN
> PROCEDURE helpnewpage               ! Help: Reset variables for a new page (*)
  a%=0
  t%=11
  x%=-13
  p%=0
  CLEARW #1
  COLOR 1,0
RETURN
> PROCEDURE helpfilefind(d$)          ! Help: Find an index-flag string
  SEEK #4,0
  fl!=FALSE
  WHILE (NOT EOF(#4)) AND fl!=FALSE
    LINE INPUT #4,t$
    IF INSTR(t$,d$)>0
      fl!=TRUE
    ENDIF
  WEND
RETURN
' --- CALCULATION (NUMBER-CRUNCHING) ------------------------------------------
> PROCEDURE fwavealloc                ! Allocate memory and arrays before calculation
  nos|=od(0)
  od2%=od(2)
  x=0
  tune=-5*prev!+5
  DIM fad%(32),pls%(32),dga%(24),dgl%(24),oc(nos|),pv(nos|)
  ' fad%()  Sample data address
  ' pls%()  Sample data length
  ' dga%()  Data-space address  -  use depends on operator type
  ' dgl%()  Data-space length
  ' oc()    Operator counter (indicates progress through waveform)
  ' pv()    Previous output value (prev. signal)
  FOR n|=1 TO nos|
    oc(n|)=d%(n|,3)
    v(n|)=0
    wv|=d%(n|,8)                ! Waveform source
    op|=d%(n|,5)
    IF op|=35 OR op|=2                  ! Reserve memory for Delay Loops
      IF f(n|)=0
        fad%=0
      ELSE
        fln%=128/f(n|)+1
        fad%=AllocMem(MUL(fln%,8),&H10001)
        IF fad%=0
          ALERT 0,"Not enough memory|for Delay Loop of|Operator "+STR$(n|),1,"Continue",a%
        ENDIF
      ENDIF
      dga%(n|)=fad%
      dgl%(n|)=fln%
    ELSE IF op|=1 AND wv|>15 AND wv|<48        ! Reserve memory for sample sources
      f$=s$(wv|)
      IF f$<>""
        OPEN "I",#2,f$
        IF fln%(wv|)>4
          IF INPUT$(4,#2)="FORM"
            pls%=4
            findbody(fln%(wv|),2,pls%)
          ELSE
            pls%=0
          ENDIF
          SEEK #2,pls%
          fln%=SUB(LOF(#2),pls%)
          sl%(wv|)=fln%
          fad%=AllocMem(ADD(fln%,16),&H10001)
          fad%(wv|)=fad%
          IF fad%>0
            BGET #2,fad%,fln%
          ELSE
            ALERT 0,"Not enough memory|for Source "+STR$(wv|),1,"Continue",a%
            sl%(wv|)=0
          ENDIF
        ENDIF
        CLOSE #2
      ELSE
        ALERT 0,"Source "+STR$(wv|)+"|file not found",1,"Continue",a%
      ENDIF
    ELSE IF wv|<48
      sl%(wv|)=0
    ENDIF
  NEXT n|
  '
  sadr%=MALLOC(ADD(od2%,2),&H10002)
  IF sadr%>0
    sampleplay(sadr%,SHR(od2%,1),16384,60)
  ENDIF
  ARRAYFILL v(),0
  ARRAYFILL ec|(),0
  REPEAT
  UNTIL MOUSEK=0
  IF prev!=FALSE AND spec!=FALSE
    OPEN "O",#3,path$
  ELSE
    COLOR 1
    IF spec!=TRUE
      FOR xx%=1 TO 20
        TEXT MUL(xx%,20),430,STR$(xx%)
      NEXT xx%
      DIM ho(512),h%(21)
    ENDIF
    eyf=MIN(93000/(od2%+revran%),16)
    exf=eyf*0.2
  ENDIF
RETURN
> PROCEDURE fwavecalc                 ! Calculate sample
  fwavealloc
  starttimer%=TIMER
  FOR xx%=1 TO ADD(od2%,revran%)
    t=tune*mtun
    x=x+t
    y=0
    xs=xx%/od2%*100
    IF xs<100
      FOR o|=nos| DOWNTO 1
        op|=d%(o|,5)  ! Operator Type
        wv|=d%(o|,8)  ! Waveform (if any)
        mx|=d%(o|,7)  ! INPUT 2
        md|=d%(o|,6)  ! INPUT 1
        ec|=ec|(o|)   ! Find Envelope Volume by Linear Interpolation
        x1=et(o|,ec|)
        x2=et(o|,ec|+1)
        y1=ep(o|,ec|)
        y2=ep(o|,ec|+1)
        g=(y2-y1)/(x2-x1)
        v=y1+(xs-x1)*g
        IF xx%/od2%>x2*0.01 AND ec|<15
          INC ec|(o|)
          IF NOT (prev! OR spec!)
            updatetimer(xs,TIMER,starttimer%)
          ENDIF
        ENDIF
        ov=v*d%(o|,4)*0.01
        SELECT op|
        CASE 1       ! WAVEFORM GENERATORS, FM & MIXING
          f1=f(o|)+d%(o|,2)*f(o|)*0.0001  ! Frequency+detune
          SELECT wv|
          CASE 0 TO 4
            oc(o|)=(oc(o|)+t*f1) MOD 640
            IF md|<>0
              a=ABS(v(md|)+oc(o|)+64000)
              y=tab(wv|,a MOD 640)*ov
            ELSE
              y=tab(wv|,ABS(x*f1+d%(o|,3)) MOD 640)*ov
            ENDIF
          CASE 16 TO 31   ! 8-BIT SAMPLES
            IF md|<>0
              dis%=ADD(f1*v(md|),d%(o|,3))
            ELSE
              dis%=0
            ENDIF
            fx%=ADD(oc(o|),dis%)
            oc(o|)=oc(o|)+t*f1*0.2
            IF fx%<sl%(wv|) AND fx%>0
              p&=PEEK(fad%(wv|)+fx%)
              p&=(p& XOR 128)-128
              y=p&/128*ov
            ELSE
              y=0
            ENDIF
          CASE 32 TO 47   ! 16-BIT SAMPLES
            IF md|<>0
              dis%=ADD(f1*v(md|),d%(o|,3))
            ELSE
              dis%=0
            ENDIF
            oct%=oc(o|)
            oc(o|)=oc(o|)+t*f1*0.4
            fx%=ADD(oct% AND &HFFFFFFFE,dis%)
            IF fx%<sl%(wv|) AND fx%>0
              p&=WORD{fad%(wv|)+fx%}
              y=p&/32768*ov
            ELSE
              y=0
            ENDIF
          ENDSELECT
        CASE 10    ! Straight Mix
          y=(v(mx|)+v(md|))*ov*0.0078125
        CASE 30    ! HF Filter
          ov=ov+1
          IF ov<1
            ov=ov+100
            thru=1/MAX(1,25-ov*0.25)
            echo=1-thru
          ELSE
            thru=ov*0.0025+1
            echo=1-thru
          ENDIF
          y=v(md|)*thru+pv(o|)*echo
          pv(o|)=y
        CASE 35    ! Delay Gate
          ct%=pv(o|)
          ov=ABS(64-ov*0.5)
          mdpek%=dga%(o|)+MUL((ct%+ov) MOD dgl%(o|),8)
          md%=dga%(o|)+MUL(ct%,8)
          y=FLOAT{mdpek%}       ! Get value
          FLOAT{md%}=v(md|)     ! Store value of input
          INC ct%               ! Inc counter
          ct%=MOD(ct%,dgl%(o|)) ! Mod to buffer size
          pv(o|)=ct%            ! Store counter
        CASE 5     ! AM / RM
          ov=ov+v(md|)*0.5-64
          y=v(mx|)*ov*0.0078125
        CASE 0
        CASE 11    ! Balance Mix
          IF ov>100
            y=v(mx|)*d%(o|,4)*0.78125
          ELSE IF ov<-100
            y=v(md|)*d%(o|,4)*0.78125
          ELSE
            y=v(mx|)*(ov*0.5+50)+v(md|)*(50-ov*0.5)
          ENDIF
          y=y*0.01
        CASE 16    ! Splice Mixing -input
          f1=f(o|)+d%(o|,2)*f(o|)*0.0001  ! Frequency+detune
          mc=200/f1
          md%=ABS(x*f1+d%(o|,3)) MOD 640
          IF md%-320<v*3.2
            y=v(mx|)*d%(o|,4)*0.01
          ELSE
            y=v(md|)*d%(o|,4)*0.01
          ENDIF
          mx|=0
        CASE 20    ! Pitch Slide
          mtun=2^(ov*0.00833333)
        CASE 40    ! Threshold Subtraction
          y=v(md|)
          IF y>0
            IF y<ov
              y=0
            ELSE
              y=y-ov
            ENDIF
          ELSE
            IF -y<ov
              y=0
            ELSE
              y=y+ov
            ENDIF
          ENDIF
        CASE 41    ! Clipping
          y=v(md|)
          IF ABS(y)>=ov
            y=ov*SGN(y)
          ENDIF
        CASE 31    ! Rectifier
          y=ABS(v(md|))
          ' CASE 2     ! PITCH MODULATION (allow for TWO inputs - see 'link!')
          ' f1=f(o|)+d%(o|,2)*f(o|)*0.0001  ! Frequency+detune
          ' ctget=oc(o|)
          ' ctput=pv(o|)
          ' ctget=ctget+t*f1*0.2*ov
          ' ov=2^(v(md|)*ov*5.4253429E-07)
          ' ctget=(ctget+ov) MOD dgl%(o|)    ! Update GET counter
          ' mdpek%=dga%(o|)+MUL((ctget+ov) MOD dgl%(o|),8)
          ' mdpok%=dga%(o|)+ABS(MUL(ctput,8))
          ' md%=dga%(o|)+MUL(ctget,8)
          ' y=FLOAT{mdpok%}       ! Get value
          ' FLOAT{md%}=v(mx|)     ! retrieve value of input op
          ' INC ctput
          ' ctput=ctput MOD dgl%(o|)
          ' pv(o|)=ctput
          ' oc(o|)=ctget
        ENDSELECT
        IF op|=1 AND mx|<>0 AND wv|<64
          y=y+v(mx|)
        ENDIF
        v(o|)=y
      NEXT o|
    ELSE
      y=0
    ENDIF
    t=MAX(-128,MIN(127,y))
    ' ---------------------------------------- GRAPHS -----------------------
    ' --------------------- PREVIEW
    IF prev!=TRUE
      px&=MOD(xx%,prevslice%)           ! draw a wave every prevslice% samples
      IF px&=1
        prevslice!=TRUE
        prevfirstslice!=TRUE
        prevwaitingstart!=TRUE
      ENDIF
      IF sadr%>0
        POKE sadr%+SHR(xx%,1),t
      ENDIF
      IF prevslice!                 ! If sample wave needs to be drawn...
        prevmodxx%=MOD(xx%,256)
        IF prevmodxx%=1             !\
          prevwaitingstart!=FALSE   ! > If arrived at start of 'wave cycle'...
        ENDIF                       !/
        IF NOT prevwaitingstart!    ! If not awaiting start of wave cycle
          xp=DIV(xx%,256)
          px&=prevmodxx%+xp*exf
          py&=SUB(SUB(420,t*0.4),MUL(xp,eyf))
          IF prevfirstslice!
            updatetimer(xs,TIMER,starttimer%)
            PLOT SHL(px&,1),py&
            prevfirstslice!=FALSE
          ELSE
            DRAW  TO SHL(px&,1),py&
          ENDIF
          IF prevmodxx%=255
            prevslice!=FALSE
          ENDIF
        ENDIF
      ENDIF
      ADD xx%,1
      ' --------------------- SPECTRUM
    ELSE IF spec!=TRUE
      IF sadr%>0
        POKE sadr%+xx%,t
      ENDIF
      ot%=MOD(xx%,specslice%)
      IF ot%<128
        ho(ot%)=t
      ENDIF
      xp=xx%\256
      IF ot%=127
        ' ---
        ihf=360/128
        updatetimer(xs,TIMER,starttimer%)
        FOR har%=1 TO 20
          ftota=0
          ftotb=0
          FOR x%=0 TO 127
            fra=har%*ihf*x%
            ADD ftota,ho(x%)*COSQ(fra)
            ADD ftotb,ho(x%)*SINQ(fra)
          NEXT x%
          h%(har%)=SQR(ftota*ftota+ftotb*ftotb)*0.014
        NEXT har%
        px&=ot+xp*exf
        py&=420-xp*eyf
        FOR n&=1 TO 20
          LINE px&+n&*20,py&,px&+n&*20+9,py&-h%(n&)
          DRAW  TO px&+n&*20+17,py&
          LINE px&+n&*20,py&,px&+n&*20+17,py&
        NEXT n&
        ARRAYFILL h%(),0
      ENDIF
    ELSE
      ' -------------------------------- SOUND MEMORY & FILE -------------------
      IF sadr%>0
        POKE sadr%+xx%,t
      ENDIF
      IF bit16!
        mi$=MKI$(t*256)
        '        mi$=RIGHT$(mi$,1)+LEFT$(mi$,1)
        PRINT #3,mi$;
      ELSE
        PRINT #3,CHR$(t);
      ENDIF
      IF xx%=350
        updatetimer(xs,TIMER,starttimer%)
      ENDIF
    ENDIF
    a$=INKEY$
    EXIT IF a$=CHR$(1)
  NEXT xx%
  updatetimer(100,TIMER,starttimer%)
  fwavedealloc
RETURN
> PROCEDURE updatetimer(xs,nowtimer%,starttimer%)
  takentime=nowtimer%-starttimer%
  IF xs>0
    ttime=takentime/xs*100
    etime=ttime-takentime
    ttime$=@maketime$(ttime)
    etime$=@maketime$(etime)
  ELSE
    ttime$=""
    etime$=""
    ttime=0
    etime=0
  ENDIF
  prompt(" Processing: "+STR$(INT(xs))+"% of "+ttime$+" (another "+etime$+").")
  COLOR 1
  BOX 217,4,639,25
  BOX 216,5,638,24
  IF NOT (prev! OR spec!)
    GRAPHMODE 2
    PBOX 219+xs*4.2,6,637,23
    GRAPHMODE 0
  ENDIF
RETURN
> PROCEDURE fwavedealloc              ! Deallocate memory after calculation
  IF sadr%>0
    sadr%=MFREE(sadr%,od(2)+revran%+2)
    CARD{&HDFF096}=&H8201
    CARD{&HDFF096}=1
  ENDIF
  FOR n|=0 TO nos|
    wv|=d%(n|,8) ! Waveform source
    op|=d%(n|,5) ! Operator type
    IF op|=35 OR op|=2                  ! Free Data memory
      IF dga%(n|)>0
        dga%=FreeMem(dga%(n|),MUL(dgl%(n|),8))
        dgl%(n|)=0
      ENDIF
    ELSE IF wv|<48 AND op|=1    ! Free Sample storage memory
      IF sl%(wv|)>0
        ad%=FreeMem(fad%(wv|),ADD(sl%(wv|),16))
        sl%(wv|)=0
      ENDIF
    ENDIF
  NEXT n|
  ERASE fad%(),pls%(),oc(),pv(),dga%(),dgl%()
  CLOSE #3
RETURN
' --- WAVEFORM SOURCES --------------------------------------------------------
> PROCEDURE waveedit                  ! Edit Sources page
  LOCAL wavestart&,hgt&,qfel!,press!,x&,y&,z&,xd&,ox&,yd,oy,y,yi,osrc|
  wavestart&=73
  hgt&=(scnht%-wavestart&-tbargap%)/2
  shgt&=DIV(hgt&,4)
  wavescreendraw
  justdrawn!=FALSE
  REPEAT
    qfel!=FALSE
    REPEAT
      press!=TRUE
      VSYNC
      MOUSE x&,y&,z&
      IF z&=0
        IF justdrawn!
          x&=ADD(MUL(src|,88),4)
          wavedraw(src|,0.125,x&+2,5,hgt&)
          frame(x&,3,ADD(x&,82),7+shgt&)
          justdrawn!=FALSE
        ENDIF
        click
        x&=xm&
        y&=ym&
        z&=MOUSEK
        oy=y&
        press!=FALSE
      ENDIF
    UNTIL z&<>0
    IF press!=FALSE
      oy&=y&
      ox&=x&
    ENDIF
    SUB y&,11
    IF y&>wavestart& AND y&<scnht%-1       ! user-Draw waveform with mouse
      IF press!=TRUE AND x&<>ox& AND z&<>0
        IF z&>1
          REPEAT
          UNTIL MOUSEK<2
        ENDIF
        ADD y&,11
        yd=SUB(y&,oy)
        xd&=SUB(x&,ox&)
        yi=yd/xd&
        s&=SGN(SUB(x&,ox&))
        FOR xx&=ox& TO x& STEP s&
          oy=oy+yi*s&
          COLOR 0
          PLOT xx&,hgt&+wavestart&-tab(src|,xx&)*128
          tab(src|,xx&)=SUB(wavestart&+hgt&,oy)/128
          COLOR 3
          PLOT xx&,oy
        NEXT xx&
        oy=y&
        '
        COLOR 0
        t=tab(src|,x&)
        PLOT x&,SUB(hgt&+wavestart&,t*128)
        y=SUB(wavestart&+hgt&,y&)/128
        tab(src|,x&)=y
        COLOR 3
        '        PLOT x&,271-y&*120
        justdrawn!=TRUE
      ENDIF
    ELSE IF y&>-9 AND y&<wavestart&-11  ! ## Upper (non-waveform) region
      press!=FALSE
      IF x&<440 AND y&<8+shgt&  ! ## small waveforms
        IF MOD(x&,88)<80
          osrc|=src|
          src|=x& DIV 88
          IF src|<>osrc|
            x&=ADD(MUL(osrc|,88),4)
            wavedraw(osrc|,0.125,x&+2,5,hgt&)
            frame(x&,3,ADD(x&,82),7+shgt&)
          ENDIF
          x&=ADD(MUL(src|,88),4)
          wavedraw(src|,0.125,x&+2,5,hgt&)
          frame(x&,3,ADD(x&,82),7+shgt&)
          wavedraw(src|,1,0,wavestart&,hgt&)
        ENDIF
      ELSE IF x&>450            ! ## Buttons
        IF MOD(SUB(x&,450),64)<56 AND MOD(ADD(y&,8),22)<20
          n|=DIV(SUB(x&,440),64)+MUL(DIV(ADD(y&,8),22),3)
          SELECT n|
          CASE 2        ! FullY
            mx=-3
            mn=3
            FOR x&=0 TO 639
              y=tab(src|,x&)
              IF y>mx
                mx=y
              ENDIF
              IF y<mn
                mn=y
              ENDIF
            NEXT x&
            mean=(mx+mn)/2
            amp=mx-mn
            IF amp<>2 AND amp<>0
              scale=2/amp
              FOR x&=0 TO 639
                y=tab(src|,x&)
                y=(y-mean)*scale
                tab(src|,x&)=y
              NEXT x&
            ENDIF
            wavedraw(src|,1,0,wavestart&,hgt&)
            x&=ADD(MUL(src|,88),4)
            wavedraw(src|,0.125,x&+2,5,hgt&)
            frame(x&,3,ADD(x&,82),7+shgt&)
          CASE 3        ! GRAB
            grab
            wavescreendraw
          CASE 4        ! DISP
            wavedraw(src|,1,0,wavestart&,hgt&)
          CASE 5        ! SINE
            wavetosine(src|)
            wavedraw(src|,1,0,wavestart&,hgt&)
          CASE 6        ! LOAD
            waveload
            wavedraw(src|,1,0,wavestart&,hgt&)
            x&=ADD(MUL(src|,88),4)
            wavedraw(src|,0.125,x&+2,5,hgt&)
            frame(x&,3,ADD(x&,82),7+shgt&)
          CASE 7        ! SAVE
            wavesave
          CASE 8        ! EXIT
            qfel!=TRUE
          ENDSELECT
        ENDIF
      ENDIF
    ENDIF
    ox&=x&
  UNTIL qfel!=TRUE
  SLEEP
RETURN
> PROCEDURE wavescreendraw            ! Draw Sources screen
  CLEARW #1
  palette(&HAAA,0,&HFFF,&HFF9)
  RESTORE sourcegadg
  FOR n|=0 TO 4
    x&=ADD(MUL(n|,88),4)
    wavedraw(n|,0.125,x&+2,5,hgt&)
    frame(x&,3,ADD(x&,82),ADD(7,shgt&))
  NEXT n|
  FOR n|=2 TO 8
    READ a$
    x&=ADD(MUL(MOD(n|,3),64),450)
    y&=ADD(MUL(DIV(n|,3),22),3)
    block(x&,y&,a$,7,1,0)
  NEXT n|
  '  TEXT 5,23,"EDIT OSCILLATOR SOURCES"
  sourcegadg:
  DATA "FullY","Grab","Disp","Sine","Load","Save","Exit"
  wavedraw(src|,1,0,wavestart&,hgt&)
RETURN
> PROCEDURE wavedraw(src|,xs,orx&,ory&,hgt&)!Plot a UD-waveform
  LOCAL stp,y,n,n|,hgt,orx,ory,y&
  COLOR 0
  PBOX orx&,ory&,orx&+640*xs,ory&+hgt&*xs*2
  COLOR 1
  IF xs=1
    TEXT 450,13,"Current:"+STR$(src|)
  ENDIF
  DEFLINE &X1000100010001000
  FOR n|=0 TO 4
    LINE orx&+n|*160*xs,ory&,orx&+n|*160*xs,ory&+xs*hgt&*2
  NEXT n|
  FOR n|=0 TO 2
    y&=ory&+(n|-1)*128*xs+(hgt&)*xs
    LINE orx&,y&,orx&+640*xs,y&
  NEXT n|
  DEFLINE 65535
  COLOR 3
  stp=1/xs
  orx=orx&
  FOR n=0 TO 640 STEP stp
    y&=tab(src|,n)*128
    tx&=n*xs+orx
    ty&=(hgt&-y&)*xs+ory&
    PLOT tx&,ty&
  NEXT n
  COLOR 1
RETURN
> PROCEDURE wavetosine(qo)            ! Reset a waveform to a sine-wave
  FOR n=0 TO 640
    tab(qo,n)=SINQ(n*0.5625)
  NEXT n
RETURN
> PROCEDURE waveload
  ' Load an "FMCW" file into wave src|
  si$=otp$
  palette(&HCCC,&H0,&HFFF,&H0)
  tpath$=@fselect$("Load Waveform","LOAD",otp$,FALSE)
  palette(&HAAA,&H0,&HFFF,&HDD0)
  IF NOT EXIST(tpath$)
    prompt("File does not exist - Click to continue.")
    click
    ipt!=FALSE
    wavescreendraw
  ENDIF
  IF ipt!=TRUE
    otp$=tpath$
    OPEN "I",#4,tpath$
    qf!=FALSE
    id$=INPUT$(4,#4)
    IF id$="FMCW"
      ver%=CVI(INPUT$(2,#4))
      ptr%=6
      REPEAT
        SEEK #4,ptr%
        hunk$=INPUT$(4,#4)
        siz%=CVI(INPUT$(2,#4))
        ADD ptr%,ADD(siz%,6)
        SELECT hunk$
        CASE "WAVE"
          FOR n&=0 TO 639
            tab(src|,n&)=(CVI(INPUT$(2,#4))-960.499)/128
          NEXT n&
        CASE "EOF!"
          qf!=TRUE
        DEFAULT
        ENDSELECT
      UNTIL qf!=TRUE
    ENDIF
    CLOSE #4
    mes$=ms$
    palette(&HAAA,0,&HFFF,&HFF9)
  ENDIF
RETURN
> PROCEDURE wavesave
  si$=otp$
  palette(&HCCC,&H0,&HFFF,&H0)
  tpath$=@fselect$("Save Waveform","SAVE",otp$,TRUE)
  palette(&HAAA,&H0,&HFFF,&HDD0)
  IF ipt!=TRUE
    otp$=tpath$
    OPEN "O",#4,tpath$
    PRINT #4,"FMCW"+MKI$(640);
    PRINT #4,"WAVE"+MKI$(1280);
    FOR n&=0 TO 639
      PRINT #4,MKI$(tab(src|,n&)*128+960.501);
    NEXT n&
    PRINT #4,"EOF!"+CHR$(0)+CHR$(0);
    CLOSE #4
  ENDIF
  palette(&HAAA,0,&HFFF,&HFF9)
RETURN
' --- SAMPLE LAB --------------------------------------------------------------
> PROCEDURE grabrangedraw(olx%,x%,yl&)
  olx%=MAX(-10,MIN(660,olx%))
  x%=MAX(-10,MIN(660,x%))
  GRAPHMODE 2
  COLOR 3
  LINE olx%,gstart%+23,olx%,gstart%+277
  LINE x%,gstart%+23,x%,gstart%+277
  GRAPHMODE 1
  COLOR 0
  PBOX 0,yl&,640,yl&+11
  COLOR 3
  TEXT x%-3,yl&+8,"�"
RETURN
> PROCEDURE grab                      ! Main controlling routine
  DIM buf&(640)         ! Memory buffer for displayed waveform
  zoom&=16              ! zoom factor: x-pixels used per sample
  gstart&=21            ! screen-y of top of sample graph
  gwaveor&=gstart&+129  ! screen-y of y-origin (y=0) of sample graph
  CLR mx&,mn&,start%    ! highest, lowest sample values
  grabscreendraw        ! Draw the basic screen
  '
  grabinfodraw          ! Show info regarding the current sample
  qgrab!=FALSE          ! Quit this routine?
  REPEAT
    zstep&=DIV(640,zoom&)       ! Number of sample points shown on screen
    click                       ! wait for mouse press
    sym&=ym&-gstart&            ! y-mouse rel.to top of sample graph
    IF fileopen!=TRUE
      IF sym&>-14 AND sym&<-4     ! File-Position Scroll-bar (top of screen)
        start%=xm&*samlen%/640    ! determine new filepos of start of graph
        start%=MIN(samlen%-zstep&,start%)    ! keep within length of file
        grabloaddisplay(2,zoom&,samlen%,start%,buf&()) ! load sample section
        grabdrawwave(buf&())      ! Draw sample graph at new pos.
        grabinfodraw              ! Show info regarding current sample
      ELSE IF sym&>1 AND sym&<258 ! INSIDE SAMPLE WAVEFORM AREA?
        grabrangedraw(-7,(stb-start%)*zoom&,287)
        grabrangedraw(-7,(enb-start%)*zoom&,300)
        REPEAT
          clickgetpos(xm&,ym&,xt|,yt|)
          sym&=ym&-gstart&            ! y-mouse rel.to top of sample graph
          IF sym&>1 AND sym&<258
            grabupdatepoint(zstep&,zoom&,xm&,ym&,buf&())
          ENDIF
        UNTIL MOUSEK=0
        grabrangedraw(-7,(stb-start%)*zoom&,287)
        grabrangedraw(-7,(enb-start%)*zoom&,300)
      ELSE IF sym&>265 AND sym&<292 ! Range Markers
        grabalterrange
      ELSE IF sym&>301 AND sym&<322 ! -------- Magnify/Movement
        grabmagmove
      ENDIF
    ENDIF
    IF sym&>333 AND sym&<354 ! -------- Transfer
      grabtransfer
    ELSE IF sym&>361              ! --- EXIT ---
      IF sym&<390 AND xm&<85
        qgrab!=TRUE
        IF fileopen!
          CLOSE #2
          fileopen!=FALSE
        ENDIF
      ENDIF
    ELSE IF NOT fileopen!
      quick("A sample file should be opened first using 'New File'")
    ENDIF
  UNTIL qgrab!
  ERASE buf&()
RETURN
> PROCEDURE grabupdatepoint(zstep&,zoom&,xm&,ym&,VAR buf&())
  LOCAL bufpos&
  ' Updates the sample graph by changing one point - buf&() is updated
  ' buf&(0..640)
  ' GLOBALS USED: sym&
  bufpos&=(xm&+zoom&*0.5)/zoom&         ! buffer pos. to NEAREST point
  buf&(bufpos&)=129-sym&                ! determine new
  IF bufpos&>0          ! Draw line left of point (if not the leftmost point)
    grabdrawgraphline(bufpos&-1,bufpos&,gstart&+2,gstart&+257,buf&(bufpos&-1),buf&(bufpos&))
  ENDIF
  IF bufpos&<zstep&     ! Draw line right of point (if not the rightmost point)
    grabdrawgraphline(bufpos&,bufpos&+1,gstart&+2,gstart&+257,buf&(bufpos&),buf&(bufpos&+1))
  ENDIF
RETURN
> PROCEDURE grabdrawgraphline(x1&,x2&,y1&,y2&,amp1&,amp2&)
  amp2&=gwaveor&-amp2&       ! reverse about axis
  amp1&=gwaveor&-amp1&       ! "
  x2&=x2&*zoom&
  x1&=x1&*zoom&
  COLOR 0
  PBOX x1&,y1&,x2&,y2&          ! clear area
  COLOR 2
  LINE x1&,gwaveor&,x2&,gwaveor&    ! origin line
  COLOR 1
  LINE x1&,amp1&,x2&,amp2&          ! graph line
RETURN
> PROCEDURE grabalterrange
  REPEAT
    xm&=MOUSEX
    mark=start%+xm&/zoom&
    IF sym&<279
      grabrangedraw((stb-start%)*zoom&,xm&,287)
      stb=mark
    ELSE
      grabrangedraw((enb-start%)*zoom&,xm&,300)
      enb=mark
    ENDIF
    grabinfodraw
  UNTIL MOUSEK=0
  '  grabdrawwave(2,zoom&,samlen%,start%)
  grabinfodraw
RETURN
> PROCEDURE grabmagmove               ! Magnify & Movement buttons
  IF xm&>483                ! Magnify
    x&=(xm&-484)
    IF x& MOD 24<17
      x&=DIV(x&,24)
      IF x&<7
        zoom&=SHL(1,x&)
        zstep&=DIV(640,zoom&)
        grabloaddisplay(2,zoom&,samlen%,start%,buf&())
        grabdrawwave(buf&())
        grabinfodraw
      ENDIF
    ENDIF
  ELSE IF xm&<394               ! -------- Movement
    x&=(xm&-82)
    IF x& MOD 54<43
      x&=DIV(x&+54,54)
      SELECT x&
      CASE 1 !Start
        start%=0
      CASE 2 !Back 1K
        start%=MAX(0,start%-1024)
      CASE 3 !Back �-sc
        start%=MAX(0,start%-zstep&/4)
      CASE 4 !Fwd  �-sc
        start%=MIN(samlen%-zstep&,start%+zstep&/4)
      CASE 5 !Fwd  1K
        start%=MIN(samlen%-zstep&,start%+1024)
      CASE 6 !End
        start%=samlen%-zstep&
      ENDSELECT
      grabloaddisplay(2,zoom&,samlen%,start%,buf&())
      grabdrawwave(buf&())
      grabinfodraw
    ENDIF
  ENDIF
RETURN
> PROCEDURE grabtransfer              ! Waveform data transfer buttons
  x&=(xm&-82)
  IF x& MOD 110<105
    x&=DIV(x&+110,110)
    IF fileopen! OR x&=1
      SELECT x&
      CASE 1  !New File
        si$=gotp$
        palette(&HCCC,&H0,&HFFF,&H0)
        gtpath$=@fselect$("Load New Voice","LOAD",gotp$,FALSE)
        palette(&HAAA,&H0,&HFFF,&HDD0)
        IF NOT (EXIST(gtpath$) AND @fileexist(gtpath$))
          quick("File is not available.")
          grabscreendraw
          ipt!=FALSE
        ENDIF
        IF ipt!=TRUE
          IF fileopen!
            CLOSE #2
          ENDIF
          gotp$=gtpath$
          OPEN "U",#2,gtpath$
          fileopen!=TRUE
          CLR start%
          samlen%=LOF(#2)
          grabloaddisplay(2,zoom&,samlen%,start%,buf&())
          grabdrawwave(buf&())
        ENDIF
      CASE 2  !Disp>File (Save)
        grabsavedisplay(2,zoom&,samlen%,start%,buf&())
        grabdrawwave(buf&())
      CASE 3  !File>Disp (UNDO)
        grabloaddisplay(2,zoom&,samlen%,start%,buf&())
        grabdrawwave(buf&())
      CASE 4  !Range>Wave(Grab)
        IF enb<stb
          SWAP stb,enb
        ENDIF
        len%=ABS(enb-stb)+1
        rst=(enb-stb)/639
        cpos=INT(stb)
        '
        SEEK #2,MAX(0,cpos-1)
        v2&=INP(#2)
        v1&=INP(#2)
        IF cpos=0       ! If at the start of the file, reset to start+1
          RELSEEK #2,cpos-1
        ENDIF
        '
        FOR x&=0 TO 639
          ptr=stb+x&*rst
          IF ptr<samlen%
            IF cpos<ptr
              v2&=v1&
              WHILE cpos<ptr
                INC cpos
                v1&=INP(#2)
              WEND
            ENDIF
            xv1&=(v1& XOR 128)-128
            xv2&=(v2& XOR 128)-128
            y=xv1&+(xv1&-xv2&)*(ptr-cpos)
            tab(src|,x&)=y/128
          ENDIF
        NEXT x&
        wavedraw(src|,0.25,2,gstart&+397,128) ! Wave
        frame(0,gstart&+394,164,gstart&+463)
      CASE 5  !Wave>Range(Replace)
        IF enb<stb
          SWAP stb,enb
        ENDIF
        len%=ABS(enb-stb)
        IF len%<>1      ! avoid /0 (length of range = 0)
          rst=640/(INT(enb+0.999)-INT(stb))  ! set range stepping
        ELSE
          rst=320
        ENDIF
        cpos=INT(stb)
        '
        SEEK #2,cpos
        FOR samplepos%=0 TO len%
          ptr=INT((samplepos%+stb-cpos)*rst)
          y=tab(src|,ptr)*128
          y=INT(MAX(MIN(y,127.99),-128))
          PRINT #2,CHR$(y);
        NEXT samplepos%
        grabloaddisplay(2,zoom&,samlen%,start%,buf&())
        grabdrawwave(buf&())
      ENDSELECT
    ELSE IF (NOT fileopen!) AND n&<>1
      quick("A sample file should be opened first using 'New File'")
    ENDIF
  ENDIF
RETURN
> PROCEDURE quick(m$)
  TEXT 220,480,m$
  DELAY 0.8
  TEXT 220,480,SPACE$(60)
RETURN
> PROCEDURE grabscreendraw            ! Draw the Grab screen
  COLOR 0,0,0
  CLEARW #1
  palette(&HAAA,0,&HFFF,&HFF9)
  COLOR 1,0,0
  frame(-2,gstart&-18,641,gstart&-3)    ! Enclose Range-Start pointer
  frame(-2,gstart&,641,gstart&+259)     ! Enclose Waveform
  frame(-2,gstart&+264,663,gstart&+293) ! Enclose Range-End pointer
  frame(0,gstart&+298,406,gstart&+325)  ! Enclose Movement Gadgets
  TEXT 8,335,"Movement"
  frame(414,gstart&+298,639,gstart&+325)! Enclose Magnify Gadgets
  TEXT 422,335,"Magnify"
  frame(0,gstart&+330,639,gstart&+357)  ! Enclose Transfer Gadgets
  TEXT 8,367,"Transfer"
  frame(0,gstart&+362,76,gstart&+389)   ! EXIT
  TEXT 24,399,"EXIT"
  grabloaddisplay(2,zoom&,samlen%,start%,buf&())
  grabdrawwave(buf&())
  grabgadgetsdraw
  wavedraw(src|,0.25,2,gstart&+397,128) ! Wave
  frame(0,gstart&+394,164,gstart&+463)
  giyo&=gstart&+372
  COLOR 0,0
  PBOX 180,giyo&,468,512
  COLOR 1
  TEXT 180,giyo&,"File: "
  TEXT 180,giyo&+16,"Sample Length:"
  TEXT 180,giyo&+28,"Display Start:"
  TEXT 180,giyo&+40,"Display End  :"
  TEXT 380,giyo&+16,"Range Len  :"
  TEXT 380,giyo&+28,"Range Start:"
  TEXT 380,giyo&+40,"Range End  :"
RETURN
> PROCEDURE grabgadgetsdraw           ! Draw buttons
  LOCAL x&,y&,n&
  RESTORE grabgadg
  FOR n&=0 TO 4         ! Transfer
    READ n$
    IF n$<>""
      x&=MUL(n&,110)
      block(x&+82,gstart&+334,n$,13,1,0)
    ENDIF
  NEXT n&
  FOR n&=0 TO 5         ! Magnify
    n$=STR$(n&+1)
    IF n$<>""
      x&=MUL(n&,24)
      block(x&+484,gstart&+302,n$,2,1,0)
    ENDIF
  NEXT n&
  FOR n&=0 TO 5         ! Movement
    READ n$
    IF n$<>""
      x&=MUL(n&,54)
      block(x&+82,gstart&+302,n$,6,1,0)
    ENDIF
  NEXT n&
  grabgadg:
  DATA New File,Save Display,Load Display,Capture Wave,Put Wave
  DATA |���,��,�,�,��,���|
RETURN
> PROCEDURE grabinfodraw              ! File & Range info
  giyo&=gstart&+372
  COLOR 0                             ! FilePos Status (& next 3 lines)
  PBOX 0,gstart&-16,639,gstart&-5
  COLOR 3
  IF samlen%>0
    const=640/samlen%
    PBOX const*start%,gstart&-16,const*(start%+zstep&),gstart&-5
    COLOR 1,0
    TEXT 222,giyo&,RIGHT$(gtpath$,36)+SPACE$(50)
    TEXT 292,giyo&+16,STR$(samlen%,8)
    TEXT 292,giyo&+28,STR$(start%,8)
    TEXT 292,giyo&+40,STR$(INT(start%+640/zoom&),8)
    len=enb-stb
    n$=STR$(INT(len),6)
    IF INT(len)<>len
      n$=n$+" +"+STR$((len-INT(len))*zoom&,2)+"/"+STR$(zoom&)
    ENDIF
    TEXT 484,giyo&+16,n$+"       "
    n$=STR$(INT(stb),6)
    IF INT(stb)<>stb
      n$=n$+" +"+STR$((stb-INT(stb))*zoom&,2)+"/"+STR$(zoom&)
    ENDIF
    TEXT 484,giyo&+28,n$+"       "
    n$=STR$(INT(enb),6)
    IF INT(enb)<>enb
      n$=n$+" +"+STR$((enb-INT(enb))*zoom&,2)+"/"+STR$(zoom&)
    ENDIF
    TEXT 484,giyo&+40,n$+"       "
  ENDIF
RETURN
> PROCEDURE grabsavedisplay(file|,zoom&,VAR samlen%,start%,buf&())
  bcount&=0
  SEEK #file|,start%+1
  FOR x&=zoom& TO 639 STEP zoom&
    INC bcount&
    p&=buf&(bcount&)
    p&=(p&+128) XOR 128
    OUT #file|,p&
  NEXT x&
  TEXT 100,gwaveor&-20,"Display has been saved to the sample file."
RETURN
> PROCEDURE grabloaddisplay(file|,zoom&,VAR samlen%,start%,buf&())
  LOCAL bcount&,p&,x&
  IF fileopen!
    start%=MIN(start%,samlen%-zstep&)
    bcount&=0
    IF start%>=0
      const=640/samlen%
      SEEK #file|,start%
      p&=INP(#file|)
      p&=(p& XOR 128)-128
      buf&(0)=p&
      FOR x&=zoom& TO 639 STEP zoom&
        INC bcount&
        p&=INP(#file|)
        p&=(p& XOR 128)-128
        buf&(bcount&)=p&
      NEXT x&
    ELSE
      TEXT 100,gwaveor&-20,"Cannot load to display."
    ENDIF
  ELSE
    TEXT 100,gwaveor&-20,"No waveform open."
  ENDIF
RETURN
> PROCEDURE grabdrawwave(VAR buf&()) ! Draw waveform
  ' GLOBAL: gwaveor& : y=0 origin for sample graph
  '         stb, enb : start range, end range markers
  '         start%   : starting file-position of displayed portion of sample
  '         zstep&   : number of sample points shown on-screen (not incl.[0])
  LOCAL bcount&,p&
  IF fileopen!
    COLOR 0
    PBOX 0,gstart&+2,639,gstart&+257
    COLOR 2
    LINE 0,gwaveor&,640,gwaveor&
    p&=buf&(0)
    COLOR 1
    PLOT 0,gwaveor&-p&
    FOR bcount&=0 TO zstep&
      p&=buf&(bcount&)
      DRAW  TO bcount&*zoom&,gwaveor&-p&
    NEXT bcount&
    grabrangedraw(-7,(stb-start%)*zoom&,287)
    grabrangedraw(-7,(enb-start%)*zoom&,300)
    grabinfodraw
  ELSE
    TEXT 100,gwaveor&-20,"No waveform loaded."
  ENDIF
RETURN
' --- SAMPLE SOURCES ----------------------------------------------------------
> PROCEDURE samples                   ! Choose samples for sources
  IF sampbank|=0
    sampbank|=16
  ENDIF
  sampscreendraw(sampbank|)
  qf!=FALSE
  REPEAT
    click
    SUB ym&,11
    IF xm&>550 AND xm&<610 AND ym&<40 AND ym&>20
      qf!=TRUE
    ELSE IF xm&>400 AND xm&<530 AND ym&<40 AND ym&>20
      sampbank|=48-sampbank|
      sampscreendraw(sampbank|)
    ELSE IF ym&>74
      n|=DIV(SUB(ym&,74),24)
      IF n|<16
        IF xm&>22 AND xm&<76
          s$(n|+sampbank|)=""
          fln%(n|+sampbank|)=0
        ELSE
          COLOR 3
          GRAPHMODE 2
          PBOX 77,ADD(MUL(n|,24),85),618,ADD(MUL(n|,24),106)
          GRAPHMODE 1
          s$=s$(n|+sampbank|)
          IF s$<>""
            fotp$=s$
          ENDIF
          si$=fotp$
          palette(&HCCC,&H0,&HFFF,&H0)
          fpath$=@fselect$("Select a Sample File","OK",fotp$,FALSE)
          palette(&HAAA,0,&HFFF,&HFF9)
          IF NOT (EXIST(fpath$) OR @fileexist(fpath$))
            prompt("File does not exist - Click to continue.")
            click
            ipt!=FALSE
          ELSE IF ipt!=TRUE
            quiet!=TRUE
            IF RIGHT$(fpath$,1)=":" OR RIGHT$(fpath$,1)="/"
              er!=TRUE
            ELSE
              OPEN "I",#2,fpath$
            ENDIF
            IF er!=TRUE
              er!=FALSE
              fpath$=""
              ipt!=FALSE
            ELSE
              fln%(n|+sampbank|)=LOF(#2)
              CLOSE #2
            ENDIF
            quiet!=FALSE
          ENDIF
          IF ipt!=TRUE
            fotp$=fpath$
            s$(n|+sampbank|)=fpath$
          ENDIF
          COLOR 0
          PBOX 77,ADD(MUL(n|,24),85),618,ADD(MUL(n|,24),106)
        ENDIF
        sampentrydraw(n|+sampbank|)
      ENDIF
    ENDIF
  UNTIL qf!=TRUE
RETURN
> PROCEDURE sampscreendraw(wv|)       ! Draw Sample sources screen
  COLOR 0,0
  CLEARW #1
  COLOR 2
  TEXT 20,43,STR$(wv| DIV 2)+"-Bit Sample Files - for use as sound sources"
  TEXT 32,75,"Erase  FILE"
  frame(20,59,620,468)
  FOR n|=0 TO 15
    sampentrydraw(n|+wv|)
    COLOR 1
    LINE 22,PRED(y&),620,PRED(y&)
    LINE 22,y&,620,y&
  NEXT n|
  frame(400,30,530,50)
  frame(550,30,610,50)
  COLOR 1
  LINE 76,60,76,466
  TEXT 410,43,STR$((48-wv|) DIV 2)+"-Bit sources"
  TEXT 566,43,"EXIT"
RETURN
> PROCEDURE sampentrydraw(n|)         ! Draw single entry in sample table
  ' GLOBAL: s$()  Sample filename
  '       fln%()  Sample lengths
  y&=ADD(MUL(n| AND 15,24),84)
  IF s$(n|)=""
    COLOR 0
    PBOX 77,ADD(y&,1),618,ADD(y&,18)
    COLOR 2
    BOX 87,ADD(y&,11),97,ADD(y&,12)
  ELSE
    COLOR 1
    TEXT 85,ADD(y&,15),RIGHT$(s$(n|),56)+SPACE$(MAX(1,SUB(54,LEN(s$(n|)))))
    TEXT 552,ADD(y&,15),STR$(fln%(n|),7)
  ENDIF
RETURN
> PROCEDURE findbody(len%,str|,VAR fptr%)!Find BODY chunk of IFF-8SVX file
  LOCAL found!
  found!=FALSE
  WHILE found!=FALSE AND fptr%<len%-4
    wrd$=INPUT$(4,#str|)
    ADD fptr%,4
    IF wrd$="BODY"
      found!=TRUE
      IF fptr%<len%-8
        ADD fptr%,8
      ENDIF
    ENDIF
  WEND
  IF found!=FALSE
    fptr%=0
  ENDIF
RETURN
' --- PROCESSING OPTIONS (CALLING FWaveCalc) ----------------------------------
> PROCEDURE process                   ! Process option
  prev!=FALSE
  palette(&HAAA,&H0,&HFFF,&HF70)
  prompt("Processing...")
  fwavecalc
  palette(&HAAA,&H0,&HFFF,&HDD0)
RETURN
> PROCEDURE spectrum                  ! Spectrograph option
  CLEARW #1
  palette(&HABC,0,&HABC,&HABC)
  PRINT AT(1,45);"Spectrograph of output waveform - Press CTRL+A to abandon.";
  specslice%=MAX(od(2)*0.05,512)
  spec!=TRUE
  fwavecalc
  spec!=FALSE
  ERASE h%(),ho()
  PRINT AT(1,45);"Click to continue.";SPACE$(40);
  click
  ~ActivateWindow(WINDOW(1))
RETURN
> PROCEDURE preview                   ! Preview option
  CLEARW #1
  palette(&HABC,0,&HABC,&HABC)
  PRINT AT(1,45);"Preview Output waveform - Press CTRL+A to abandon.";
  prev!=TRUE
  prevfirstslice!=TRUE
  prevslice!=TRUE
  prevslice%=MAX(od(2)*0.025,256)
  fwavecalc
  prev!=FALSE
  PRINT AT(1,45);"Click to continue.";SPACE$(40);
  click
  ~ActivateWindow(WINDOW(1))
RETURN
' --- GRAPHIC ROUTINES: GENERAL -----------------------------------------------
> PROCEDURE palette(c1&,c2&,c3&,c4&)  ! Set Screen colours
  SETCOLOR 0,c1&
  SETCOLOR 1,c2&
  SETCOLOR 2,c3&
  SETCOLOR 3,c4&
RETURN
> PROCEDURE block(qx,qy,qm$,ql,qf,qb) ! Draw solid box with centred text
  LOCAL w,h
  w=qx+ql*8
  h=qy+19
  IF qb<>0
    COLOR qb
    PBOX qx,qy,w,h
  ENDIF
  frame(qx,qy,w,h)
  COLOR qf,qb
  qx1=(w+qx)/2-LEN(qm$)*4
  TEXT qx1+1,qy+12,qm$
RETURN
> PROCEDURE frame(fx,fy,fw,fh)        ! Draw pseudo-3D frame
  COLOR 2
  LINE fx,fy,fw,fy
  LINE fx,fy+1,fw,fy+1
  LINE fx,fy,fx,fh
  LINE fx+1,fy,fx+1,fh
  COLOR 1
  LINE fx+2,fh-1,fw,fh-1
  LINE fx+1,fh,fw,fh
  LINE fw,fy+1,fw,fh
  LINE fw-1,fy+2,fw-1,fh
RETURN
> PROCEDURE prompt(m$)                ! Show text at top of screen
  COLOR 0
  PBOX promptx&,4,640,25
  COLOR 1
  TEXT promptx&+6,17,m$
RETURN
' --- MOUSE HANDLING ----------------------------------------------------------
> PROCEDURE click                     ! Tell OS to wait for mouse click
  esc!=FALSE
  REPEAT
    ~WaitPort(LPEEK(ADD(win%,86)))
    SLEEP
    a$=INKEY$
    IF a$="X"
      crosshair
    ENDIF
  UNTIL esc!=TRUE AND MOUSEK>0
  clickgetpos(xm&,ym&,xt|,yt|)
RETURN
> PROCEDURE clickgetpos(VAR xm&,ym&,xt|,yt|)
  xm&=DPEEK(win%+108)
  ym=DPEEK(win%+110)
  IF ym>0
    ym&=ym
  ENDIF
  xt|=SUCC(SHR(xm&,3))
  yt|=MAX(0,SUCC(DIV(ym&,11)))
RETURN
> PROCEDURE capturemouse              ! Change global flag for mouse click
  IF MENU(2)=104
    esc!=TRUE
  ELSE IF MENU(2)=232
    esc!=FALSE
  ENDIF
RETURN
' --- FONT ROUTINES (c) GFA? --------------------------------------------------
> PROCEDURE softfont                       ! GFA: Load FMC fonts
  csi$=CHR$(&H9B)
  esc$=CHR$(27)
  '                               ! Resetet den Font der Console
  ris$=esc$+"c"+esc$+"[8m"                  ! auf den Font des Rastports
  '                               ! -> neuer Font beim PRINT - Befehl!
  loadfont("FMC",11,topaz11%)          ! Fonts laden...
  loadfont("topaz",8,topaz8%)           ! <- default Font Topaz 8/10
  '
  rp%={ADD(WINDOW(1),50)}
  '
  @setfont(rp%,topaz11%)              ! Font aktivieren
  PRINT csi$;"0;31;40m";          ! Hiermit wird die Form und Farbe ge�ndert
RETURN
> PROCEDURE loadfont(font$,size&,VAR font%)! GFA: Load a font
  LOCAL l$,t$
  '
  l$="diskfont.library"+CHR$(0)
  IF dfont_lib%=0
    ~FRE(0)
    dfont_lib%=OpenLibrary(V:l$,0)
  ENDIF
  '
  IF dfont_lib%
    '
    IF font%<>0
      ~CloseFont(font%)
      ~RemFont(font%)
      font%=0
    ENDIF
    '
    font$=font$+".font"+CHR$(0)
    ~FRE(0)
    t$=MKL$(V:font$)+MKI$(size&)+MKI$(0)
    font%=OpenFont(V:t$)                ! ROM-Font?
    IF (font%=0) OR (INT(font%)<>size&)
      font%=OpenDiskFont(V:t$)          ! DISK-Font
    ENDIF
    IF font%=0
      PRINT "FMC needs ";font$;" to be in the FONTS: directory!"
    ENDIF
  ELSE
    PRINT "FMC needs the diskfont.library - I can't find it!"
  ENDIF
RETURN
> PROCEDURE closefont(font%)               ! GFA: Remove a font
  IF font%<>0
    ~CloseFont(font%)
    ~RemFont(font%)
    font%=0
  ENDIF
RETURN
> PROCEDURE setfont(rp%,font%)             ! GFA: Use a font
  IF rp%<>0 AND font%<>0
    ~SetFont(rp%,font%)
    ~SetSoftStyle(rp%,0,AskSoftStyle(rp%))
    PRINT ris$;                             ! For Print
  ENDIF
RETURN
' --- MISC --------------------------------------------------------------------
PROCEDURE trapper                   ! Program error trapper
  er!=TRUE
  IF quiet!=FALSE
    ALERT 0,ERR$(ERR)+"|"+rt$,0,"Continue",a%
  ENDIF
  ON ERROR GOSUB trapper
  RESUME NEXT
RETURN
> PROCEDURE exampleoffm               ! -- Example FM - not a part of FMC
  LOCAL rt$
  rt$="Example FM"
  f1=1
  f2=3
  FOR n=0 TO 640
    y=SINQ(64*f1*SINQ(n*f2)+n)
    PLOT n,y*100+128
  NEXT n
  EDIT
RETURN
> PROCEDURE crosshair                 ! Coordinate/debugging tool
  REPEAT
  UNTIL MOUSEK=0
  win%=WINDOW(1)
  qut!=TRUE
  TEXT 304,240,"X:"
  TEXT 304,256,"Y:"
  GRAPHMODE 2
  LINE xm&,0,xm&,512
  LINE 0,ym&,640,ym&
  REPEAT
    oxm&=xm&
    oym&=ym&
    xm&=MOUSEX
    ym&=SUB(MOUSEY,tbargap%) !&*
    IF oxm&<>xm& OR oym&<>ym&
      GRAPHMODE 1
      TEXT 320,240,STR$(xm&)+"   "
      TEXT 320,256,STR$(ym&)+"   "
      GRAPHMODE 2
      LINE oxm&,0,oxm&,512
      LINE 0,oym&,640,oym&
      LINE xm&,0,xm&,512
      LINE 0,ym&,640,ym&
    ENDIF
  UNTIL MOUSEK>0
  GRAPHMODE 1
RETURN
> PROCEDURE progdata                  ! Initiallization data
  vcdat:
  '    Freq DtunPha Out,Op,INP1,INP2,SRC
  DATA 1.00,000,000,128,01,0000,0000,0
  envp:
  '    Time1 Vol1 ,...
  DATA -1,100,100,100,100,0,100,0,100,0,100,0,100,0,100,0,100,0,100,0,100,0,100,0,100,0,100,0,100,0,100,0
  opt:
  DATA 1,3,"Operators Selected"
  DATA 4,20,"Operator Type"
  DATA 21,30,"Frequency"
  DATA 31,36,"Detune: +1 = +0.01% of the operator's frequency"
  DATA 37,42,"Phase Shift 0 to 640 (640 = a wave cycle)"
  DATA 43,47,"Output Level (127=Full)"
  DATA 48,52,"Link "
  DATA 53,57,"Link "
  DATA 58,65,"Waveform/Sample Source"
  DATA 66,81,""
  '  reverbdata:
  '  DATA 500,1,.7,0,0,0
  gad:
  DATA "Reset Op","Delete Op","Insert Op","Number Op","Help!","Samples","Waveforms","Envelopes","","Spectrum","Preview","Generate","","Quit","Load Voice","Save Voice"
RETURN
> PROCEDURE sampleplay(qadd%,qlen%,qrate%,qvol%) ! Start playing a sample
  audlch%=&HDFF0A0
  audlen%=&HDFF0A4
  audper%=&HDFF0A6
  audvol%=&HDFF0A8
  per%=3579546/qrate%
  LPOKE audlch%,qadd%
  DPOKE audlen%,qlen%
  CARD{audvol%}=qvol%
  DPOKE audper%,per%
  CARD{&HDFF096}=1
  CARD{&HDFF09E}=&HFF
  CARD{&HDFF096}=&H8201
  '  LPOKE audlch%,qadd%
  '  CARD{audlen%}=qlen%
  t%=TIMER
RETURN
' --- FUNCTIONS ---------------------------------------------------------------
FUNCTION maketime$(itimer)
  '  n=od(2)*od(0)*0.000053548
  '  n=ROUND(n*timing%)
  n=ROUND(itimer*0.05)*0.1
  IF n>60
    n=INT(n/6)*0.1
    n$=" min"
  ELSE
    n$=" sec"
  ENDIF
  IF n<>1
    n$=n$+"s"
  ENDIF
  RETURN STR$(n)+n$
ENDFUNC
FUNCTION fselect$(prompt$,ok$,i$,sav!)     ! FILESELECT with a memory
  ' sav!=TRUE when saving (ie. no check for existent file)
  FILESELECT prompt$,"OK",si$,i$
  IF i$=""
    ipt!=FALSE
  ELSE
    ipt!=TRUE
    IF NOT (@fileexist(i$) OR sav!)
      i$=si$
      ipt!=FALSE
    ENDIF
  ENDIF
  RETURN i$
ENDFUNC
FUNCTION ipt(qw,qe,xo,yo)             ! String -> numeric INPUT, with memory
  ' qw=number; qe=MaxLength; xo=Xoffset; yo=Yoffset
  LOCAL i$
  i$=STR$(qw)
  PRINT CHR$(27)+"["+CHR$(yo+48)+"y"+CHR$(27)+"["+CHR$(xo+48)+"x";
  FORM INPUT qe AS i$
  prompt("")
  RETURN VAL(i$)
ENDFUNC
FUNCTION paraminp(m$,num,fig|)        ! Input for INFO options on Main Screen
  LOCAL in
  prompt(m$)
  COLOR 0
  PBOX 422,29,637,88
  PRINT AT(68-SHR(fig|,1),4);
  in=@ipt(num,fig|,4,6)
  prompt("")
  RETURN in
ENDFUNC
FUNCTION lock(name%,type%)
  m68%(1)=name%
  m68%(2)=type%
  m68%(14)=_DosBase
  RCALL _DosBase-84,m68%()
  RETURN m68%(0)
ENDFUNC
FUNCTION unlock(lock%)
  m68%(1)=lock%
  m68%(14)=_DosBase
  RCALL _DosBase-90,m68%()
  RETURN m68%(0)
ENDFUNC
FUNCTION examine(lock%,fileinfoblock%)
  m68%(1)=lock%
  m68%(2)=fileinfoblock%
  m68%(14)=_DosBase
  RCALL _DosBase-102,m68%()
  RETURN m68%(0)
ENDFUNC
FUNCTION fileexist(f$)
  LOCAL ex!
  ex!=TRUE
  f$=f$+CHR$(0)
  lock%=@lock(VARPTR(f$),0)
  IF lock%=0
    ex!=FALSE
  ELSE
    fio%=AllocMem(260,&H10001)
    IF fio%<>0
      exam%=Examine(lock%,fio%)
      IF LPEEK(fio%+4)=2
        ex!=FALSE
      ENDIF
      ~FreeMem(fio%,260)
    ENDIF
    lock%=@unlock(lock%)
  ENDIF
  RETURN ex!
ENDFUNC
' --- END ---------------------------------------------------------------------
